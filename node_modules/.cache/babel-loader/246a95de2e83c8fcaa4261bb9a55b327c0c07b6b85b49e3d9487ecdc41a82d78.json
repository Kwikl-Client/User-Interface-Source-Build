{"ast":null,"code":"import { PathElement, Rect, Point, Size, RotateTransform, TextElement, randomId, identityMatrix, rotateMatrix, transformPointByMatrix, intersect3 } from '@syncfusion/ej2-drawings';\nimport { setElementStype, findPointsLength } from './drawing-util';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {PointModel[]} - Returns the annotation points model array.\n */\nexport function getConnectorPoints(obj, points) {\n  points = obj.vertexPoints;\n  var newPoints = points.slice(0);\n  if (newPoints && newPoints.length > 0) {\n    obj.sourcePoint = newPoints[0];\n    obj.targetPoint = newPoints[newPoints.length - 1];\n  }\n  return newPoints;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {string} - Returns the annotation path value.\n */\nexport function getSegmentPath(connector, points) {\n  var path = '';\n  var getPt;\n  var pts = [];\n  var j = 0;\n  while (j < points.length) {\n    pts.push({\n      x: points[parseInt(j.toString(), 10)].x,\n      y: points[parseInt(j.toString(), 10)].y\n    });\n    j++;\n  }\n  pts = clipDecorators(connector, pts);\n  for (var k = 0; k < pts.length; k++) {\n    getPt = pts[parseInt(k.toString(), 10)];\n    if (k === 0) {\n      path = 'M' + getPt.x + ' ' + getPt.y;\n    }\n    if (k > 0) {\n      path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n    }\n  }\n  return path;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @param {PathElement} element - Specified the annotation element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function updateSegmentElement(connector, points, element) {\n  var bounds = new Rect();\n  var segmentPath = getSegmentPath(connector, points);\n  bounds = Rect.toBounds(points);\n  element.width = bounds.width;\n  element.height = bounds.height;\n  element.offsetX = bounds.x + element.width / 2;\n  element.offsetY = bounds.y + element.height / 2;\n  element.data = segmentPath;\n  if (connector.wrapper) {\n    connector.wrapper.offsetX = element.offsetX;\n    connector.wrapper.offsetY = element.offsetY;\n    connector.wrapper.width = bounds.width;\n    connector.wrapper.height = bounds.height;\n  }\n  return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PathElement} segmentElement - Specified the annotation segment element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function getSegmentElement(connector, segmentElement) {\n  var points = [];\n  points = getConnectorPoints(connector);\n  segmentElement.staticSize = true;\n  segmentElement = updateSegmentElement(connector, points, segmentElement);\n  setElementStype(connector, segmentElement);\n  return segmentElement;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {DrawingElement} element - Specified the annotation drawing element.\n * @param {PointModel} pt - Specified the annotation point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {void}\n */\nexport function updateDecoratorElement(obj, element, pt, adjacentPoint, isSource) {\n  element.offsetX = pt.x;\n  element.offsetY = pt.y;\n  var angle = Point.findAngle(pt, adjacentPoint);\n  var getPath = getDecoratorShape(isSource ? obj.sourceDecoraterShapes : obj.taregetDecoraterShapes);\n  var thickness = 0;\n  var size;\n  if (obj.shapeAnnotationType === 'LineWidthArrowHead') {\n    thickness = obj.thickness;\n    size = new Size(thickness * 12, thickness * 12);\n  } else {\n    thickness = obj.thickness <= 5 ? 5 : obj.thickness;\n    size = new Size(thickness * 2, thickness * 2);\n  }\n  element.transform = RotateTransform.Self;\n  setElementStype(obj, element);\n  element.style.fill = obj.fillColor !== 'tranparent' ? obj.fillColor : 'white';\n  element.rotateAngle = angle;\n  element.data = getPath;\n  element.canMeasurePath = true;\n  element.width = size.width;\n  element.height = size.height;\n  if (obj.sourceDecoraterShapes === 'Butt') {\n    element.width = size.width - 10;\n    element.height = size.height + 10;\n  }\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} offsetPoint - Specified the annotation offset point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function getDecoratorElement(obj, offsetPoint, adjacentPoint, isSource) {\n  var decEle = new PathElement();\n  updateDecoratorElement(obj, decEle, offsetPoint, adjacentPoint, isSource);\n  return decEle;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation object.\n * @param {PointModel[]} pts - Specified the annotation point model array.\n * @returns {PointModel[]} - Returns the annotation point model array.\n */\nexport function clipDecorators(connector, pts) {\n  pts[0] = clipDecorator(connector, pts, true);\n  pts[pts.length - 1] = clipDecorator(connector, pts, false);\n  return pts;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel[]} points - Specified the annotation offset point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PointModel} - Returns the annotation point model.\n */\nexport function clipDecorator(connector, points, isSource) {\n  var point = {\n    x: 0,\n    y: 0\n  };\n  var start = {\n    x: 0,\n    y: 0\n  };\n  var end = {\n    x: 0,\n    y: 0\n  };\n  var length = points.length;\n  start = !isSource ? points[length - 1] : points[0];\n  end = !isSource ? points[length - 2] : points[1];\n  var len = Point.distancePoints(start, end);\n  len = len === 0 ? 1 : len;\n  var width = connector.thickness;\n  point.x = Math.round(start.x + width * (end.x - start.x) / len);\n  point.y = Math.round(start.y + width * (end.y - start.y) / len);\n  var strokeWidth = 1;\n  point = Point.adjustPoint(point, end, true, strokeWidth / 2);\n  return point;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\nexport function initDistanceLabel(obj, points, measure, pdfviewer) {\n  var labels = [];\n  var angle = Point.findAngle(points[0], points[1]);\n  var textele = textElement(obj, angle);\n  if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n    textele.content = obj.notes;\n  } else {\n    textele.content = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n  }\n  textele.rotateValue = {\n    y: -10,\n    angle: angle\n  };\n  if (obj.enableShapeLabel === true) {\n    textele.style.strokeColor = obj.labelBorderColor;\n    textele.style.fill = obj.labelFillColor;\n    textele.style.fontSize = obj.fontSize;\n    textele.style.color = obj.fontColor;\n    textele.style.fontFamily = obj.fontFamily;\n  }\n  labels.push(textele);\n  return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the distance value.\n */\nexport function updateDistanceLabel(obj, points, measure) {\n  var distance;\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_1 = obj.wrapper.children[parseInt(i.toString(), 10)];\n    if (textElement_1 && !isNullOrUndefined(textElement_1.content)) {\n      distance = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n      textElement_1.content = distance;\n      textElement_1.childNodes[0].text = textElement_1.content;\n      textElement_1.refreshTextElement();\n    }\n  }\n  return distance;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the radius label value.\n */\nexport function updateRadiusLabel(obj, measure) {\n  var radius;\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_2 = obj.wrapper.children[parseInt(i.toString(), 10)];\n    if (textElement_2 && !isNullOrUndefined(textElement_2.content)) {\n      radius = measure.setConversion(obj.bounds.width / 2 * measure.pixelToPointFactor, obj);\n      textElement_2.content = radius;\n      if (textElement_2.childNodes.length === 2) {\n        textElement_2.childNodes[0].text = radius;\n        textElement_2.childNodes.splice(textElement_2.childNodes.length - 1, 1);\n      } else {\n        textElement_2.childNodes[0].text = radius;\n      }\n      textElement_2.refreshTextElement();\n    }\n  }\n  return radius;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\nexport function initPerimeterLabel(obj, points, measure, pdfviewer) {\n  var labels = [];\n  var angle = Point.findAngle(points[0], points[1]);\n  var textele = textElement(obj, angle);\n  if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n    textele.content = obj.notes;\n  } else {\n    textele.content = measure.calculatePerimeter(obj);\n  }\n  if (obj.enableShapeLabel === true) {\n    textele.style.strokeColor = obj.labelBorderColor;\n    textele.style.fill = obj.labelFillColor;\n    textele.style.fontSize = obj.fontSize;\n    textele.style.color = obj.fontColor;\n    textele.style.fontFamily = obj.fontFamily;\n  }\n  textele.rotateValue = {\n    y: -10,\n    angle: angle\n  };\n  labels.push(textele);\n  return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the perimeter label value.\n */\nexport function updatePerimeterLabel(obj, points, measure) {\n  var perimeter;\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_3 = obj.wrapper.children[parseInt(i.toString(), 10)];\n    if (textElement_3 && !isNullOrUndefined(textElement_3.content)) {\n      perimeter = measure.calculatePerimeter(obj);\n      textElement_3.content = perimeter;\n      textElement_3.childNodes[0].text = textElement_3.content;\n      textElement_3.refreshTextElement();\n    }\n  }\n  return perimeter;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nexport function removePerimeterLabel(obj) {\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_4 = obj.wrapper.children[parseInt(i.toString(), 10)];\n    if (textElement_4 && !isNullOrUndefined(textElement_4.content)) {\n      obj.wrapper.children.splice(i, 1);\n    }\n  }\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nexport function updateCalibrateLabel(obj) {\n  if (obj.wrapper && obj.wrapper.children) {\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n      var textElement_5 = obj.wrapper.children[parseInt(i.toString(), 10)];\n      if (textElement_5 && !isNullOrUndefined(textElement_5.content)) {\n        textElement_5.content = obj.notes;\n        textElement_5.childNodes[0].text = textElement_5.content;\n        textElement_5.refreshTextElement();\n      }\n    }\n  }\n}\n/**\n * Used to find the path for polygon shapes\n *\n * @param {PointModel[]} collection - Specified the polygon annotaion points collection.\n * @hidden\n * @returns {string} - Returns the polygon annotation path.\n */\nexport function getPolygonPath(collection) {\n  var path = '';\n  var seg;\n  path = 'M' + collection[0].x + ' ' + collection[0].y;\n  var i;\n  for (i = 1; i < collection.length; i++) {\n    seg = collection[parseInt(i.toString(), 10)];\n    path += 'L' + seg.x + ' ' + seg.y;\n  }\n  path += 'Z';\n  return path;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {number} angle - Specified the annotaion rotation angle.\n * @hidden\n * @returns {TextElement} - Returns the annotation text element.\n */\nexport function textElement(obj, angle) {\n  var textele = new TextElement();\n  setElementStype(obj, textele);\n  textele.style.fill = 'transparent';\n  textele.id = randomId();\n  textele.horizontalAlignment = 'Center';\n  textele.rotateValue = {\n    y: 10,\n    angle: angle\n  };\n  textele.verticalAlignment = 'Top';\n  textele.relativeMode = 'Object';\n  textele.setOffsetWithRespectToBounds(.5, .5, 'Absolute');\n  // eslint-disable-next-line\n  textele.offsetX;\n  textele.style.textWrapping = 'NoWrap';\n  return textele;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotaion leader points.\n * @hidden\n * @returns {PathElement[]} - Returns the annotation path elements.\n */\nexport function initLeaders(obj, points) {\n  var leaders = [];\n  var leader = initLeader(obj, points[0], points[1]);\n  leaders.push(leader);\n  leader = initLeader(obj, points[1], points[0], true);\n  leaders.push(leader);\n  return leaders;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} point1 - Specified the annotaion leader point1.\n * @param {PointModel} point2 - Specified the annotaion leader point2.\n * @param {boolean} isSecondLeader - Specified the is second leader or not.\n * @hidden\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function initLeader(obj, point1, point2, isSecondLeader) {\n  var element = new PathElement();\n  element.offsetX = point1.x;\n  element.offsetY = point1.y;\n  var angle = Point.findAngle(point1, point2);\n  var center = {\n    x: (point1.x + point2.x) / 2,\n    y: (point1.y + point2.y) / 2\n  };\n  var matrix = identityMatrix();\n  rotateMatrix(matrix, 0 - angle, center.x, center.y);\n  var rotatedPoint = transformPointByMatrix(matrix, point1);\n  var newPoint1 = {\n    x: rotatedPoint.x,\n    y: rotatedPoint.y - obj.leaderHeight\n  };\n  matrix = identityMatrix();\n  rotateMatrix(matrix, angle, element.offsetX, element.offsetY);\n  rotatedPoint = transformPointByMatrix(matrix, newPoint1);\n  var finalPoint = {\n    x: point1.x,\n    y: point1.y\n  };\n  element.offsetX = finalPoint.x;\n  element.offsetY = finalPoint.y;\n  element.transform = RotateTransform.Self;\n  var getPath = 'M' + point1.x + ',' + point1.y + ',L' + rotatedPoint.x + ',' + rotatedPoint.y + 'Z';\n  var size = new Size(0, obj.leaderHeight);\n  element.pivot.x = .5;\n  if (isSecondLeader) {\n    element.id = 'leader2_' + randomId();\n    element.pivot.y = 0;\n  } else {\n    element.id = 'leader1_' + randomId();\n    element.pivot.y = 1;\n  }\n  setElementStype(obj, element);\n  element.rotateAngle = angle;\n  element.data = getPath;\n  element.canMeasurePath = true;\n  element.width = size.width;\n  element.height = size.height;\n  return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel} reference - Specified the pointer reference value.\n * @returns {boolean} - Returns true or false.\n */\nexport function isPointOverConnector(connector, reference) {\n  var vertexPoints = connector.vertexPoints;\n  if (!isNullOrUndefined(vertexPoints)) {\n    for (var i = 0; i < vertexPoints.length - 1; i++) {\n      var start = vertexPoints[parseInt(i.toString(), 10)];\n      var end = vertexPoints[i + 1];\n      var rect = Rect.toBounds([start, end]);\n      rect.Inflate(10);\n      if (rect.containsPoint(reference)) {\n        var intersectinPt = findNearestPoint(reference, start, end);\n        var segment1 = {\n          x1: start.x,\n          x2: end.x,\n          y1: start.y,\n          y2: end.y\n        };\n        var segment2 = {\n          x1: reference.x,\n          x2: intersectinPt.x,\n          y1: reference.y,\n          y2: intersectinPt.y\n        };\n        var intersectDetails = intersect3(segment1, segment2);\n        if (intersectDetails.enabled) {\n          var distance = Point.findLength(reference, intersectDetails.intersectPt);\n          if (Math.abs(distance) < 10) {\n            return true;\n          }\n        } else {\n          var rect_1 = Rect.toBounds([reference, reference]);\n          rect_1.Inflate(3);\n          if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {\n            return true;\n          }\n        }\n        if (Point.equals(reference, intersectinPt)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n/**\n * @param {PointModel} reference - Specified the pointer reference value.\n * @param {PointModel} start - Specified the pointer start value.\n * @param {PointModel} end - Specified the pointer end value.\n * @private\n * @returns {PointModel} - Returns annotation point model.\n */\nexport function findNearestPoint(reference, start, end) {\n  var shortestPoint;\n  var shortest = Point.findLength(start, reference);\n  var shortest1 = Point.findLength(end, reference);\n  if (shortest > shortest1) {\n    shortestPoint = end;\n  } else {\n    shortestPoint = start;\n  }\n  var angleBWStAndEnd = Point.findAngle(start, end);\n  var angleBWStAndRef = Point.findAngle(shortestPoint, reference);\n  var r = Point.findLength(shortestPoint, reference);\n  var vaAngle = angleBWStAndRef + (angleBWStAndEnd - angleBWStAndRef) * 2;\n  return {\n    x: shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180),\n    y: shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180)\n  };\n}\n/**\n * @param {DecoratorShapes} shape - Specified the annotation decorator shapes.\n * @hidden\n * @returns {string} - Returns the annotation decorator shape value.\n */\nexport function getDecoratorShape(shape) {\n  // eslint-disable-next-line\n  return decoratorShapes[shape];\n}\nvar decoratorShapes = {\n  'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',\n  'Square': 'M0,0 L10,0 L10,10 L0,10 z',\n  'Fletch': 'M14.8,10c0,0-3.5,6,0.2,12c0,0-2.5-6-10.9-6C4.1,16,11.3,16,14.8,10z',\n  'OpenFetch': 'M6,17c-0.6,0-1-0.4-1-1s0.4-1,1-1c10.9,0,11-5,11-5' + 'c0-0.6,0.4-1,1-1s1,0.4,1,1C19,10.3,18.9,17,6,17C6,17,6,17,6,17z ' + 'M18,23c-0.5,0-1-0.4-1-1c0-0.2-0.3-5-11-5c-0.6,0-1-0.5-1-1s0.4-1,1-1c0,0,0,0,0,0' + 'c12.9,0,13,6.7,13,7    C19,22.6,18.6,23,18,23z',\n  'IndentedArrow': 'M17,10c0,0-4.5,5.5,0,12L5,16L17,10z',\n  'OutdentedArrow': 'M14.6,10c0,0,5.4,6,0,12L5,16L14.6,10z',\n  'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',\n  'Arrow': 'M15,10 L15,22 L5,16Z',\n  'Diamond': 'M12,23l-7-7l7-7l6.9,7L12,23z',\n  'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z',\n  'Butt': 'M0,0 L0,90'\n};","map":{"version":3,"names":["PathElement","Rect","Point","Size","RotateTransform","TextElement","randomId","identityMatrix","rotateMatrix","transformPointByMatrix","intersect3","setElementStype","findPointsLength","isNullOrUndefined","getConnectorPoints","obj","points","vertexPoints","newPoints","slice","length","sourcePoint","targetPoint","getSegmentPath","connector","path","getPt","pts","j","push","x","parseInt","toString","y","clipDecorators","k","updateSegmentElement","element","bounds","segmentPath","toBounds","width","height","offsetX","offsetY","data","wrapper","getSegmentElement","segmentElement","staticSize","updateDecoratorElement","pt","adjacentPoint","isSource","angle","findAngle","getPath","getDecoratorShape","sourceDecoraterShapes","taregetDecoraterShapes","thickness","size","shapeAnnotationType","transform","Self","style","fill","fillColor","rotateAngle","canMeasurePath","getDecoratorElement","offsetPoint","decEle","clipDecorator","point","start","end","len","distancePoints","Math","round","strokeWidth","adjustPoint","initDistanceLabel","measure","pdfviewer","labels","textele","textElement","enableImportAnnotationMeasurement","notes","content","setConversion","pixelToPointFactor","rotateValue","enableShapeLabel","strokeColor","labelBorderColor","labelFillColor","fontSize","color","fontColor","fontFamily","updateDistanceLabel","distance","i","children","textElement_1","childNodes","text","refreshTextElement","updateRadiusLabel","radius","textElement_2","splice","initPerimeterLabel","calculatePerimeter","updatePerimeterLabel","perimeter","textElement_3","removePerimeterLabel","textElement_4","updateCalibrateLabel","textElement_5","getPolygonPath","collection","seg","id","horizontalAlignment","verticalAlignment","relativeMode","setOffsetWithRespectToBounds","textWrapping","initLeaders","leaders","leader","initLeader","point1","point2","isSecondLeader","center","matrix","rotatedPoint","newPoint1","leaderHeight","finalPoint","pivot","isPointOverConnector","reference","rect","Inflate","containsPoint","intersectinPt","findNearestPoint","segment1","x1","x2","y1","y2","segment2","intersectDetails","enabled","findLength","intersectPt","abs","rect_1","equals","shortestPoint","shortest","shortest1","angleBWStAndEnd","angleBWStAndRef","r","vaAngle","cos","PI","sin","shape","decoratorShapes"],"sources":["/Users/saleem/Desktop/KClient/Web App/Ver_3.6/User Interface/website_Source files/node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/connector-util.js"],"sourcesContent":["import { PathElement, Rect, Point, Size, RotateTransform, TextElement, randomId, identityMatrix, rotateMatrix, transformPointByMatrix, intersect3 } from '@syncfusion/ej2-drawings';\nimport { setElementStype, findPointsLength } from './drawing-util';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {PointModel[]} - Returns the annotation points model array.\n */\nexport function getConnectorPoints(obj, points) {\n    points = obj.vertexPoints;\n    var newPoints = points.slice(0);\n    if (newPoints && newPoints.length > 0) {\n        obj.sourcePoint = newPoints[0];\n        obj.targetPoint = newPoints[newPoints.length - 1];\n    }\n    return newPoints;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {string} - Returns the annotation path value.\n */\nexport function getSegmentPath(connector, points) {\n    var path = '';\n    var getPt;\n    var pts = [];\n    var j = 0;\n    while (j < points.length) {\n        pts.push({ x: points[parseInt(j.toString(), 10)].x, y: points[parseInt(j.toString(), 10)].y });\n        j++;\n    }\n    pts = clipDecorators(connector, pts);\n    for (var k = 0; k < pts.length; k++) {\n        getPt = pts[parseInt(k.toString(), 10)];\n        if (k === 0) {\n            path = 'M' + getPt.x + ' ' + getPt.y;\n        }\n        if (k > 0) {\n            path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n        }\n    }\n    return path;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @param {PathElement} element - Specified the annotation element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function updateSegmentElement(connector, points, element) {\n    var bounds = new Rect();\n    var segmentPath = getSegmentPath(connector, points);\n    bounds = Rect.toBounds(points);\n    element.width = bounds.width;\n    element.height = bounds.height;\n    element.offsetX = bounds.x + element.width / 2;\n    element.offsetY = bounds.y + element.height / 2;\n    element.data = segmentPath;\n    if (connector.wrapper) {\n        connector.wrapper.offsetX = element.offsetX;\n        connector.wrapper.offsetY = element.offsetY;\n        connector.wrapper.width = bounds.width;\n        connector.wrapper.height = bounds.height;\n    }\n    return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PathElement} segmentElement - Specified the annotation segment element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function getSegmentElement(connector, segmentElement) {\n    var points = [];\n    points = getConnectorPoints(connector);\n    segmentElement.staticSize = true;\n    segmentElement = updateSegmentElement(connector, points, segmentElement);\n    setElementStype(connector, segmentElement);\n    return segmentElement;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {DrawingElement} element - Specified the annotation drawing element.\n * @param {PointModel} pt - Specified the annotation point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {void}\n */\nexport function updateDecoratorElement(obj, element, pt, adjacentPoint, isSource) {\n    element.offsetX = pt.x;\n    element.offsetY = pt.y;\n    var angle = Point.findAngle(pt, adjacentPoint);\n    var getPath = getDecoratorShape(isSource ? obj.sourceDecoraterShapes : obj.taregetDecoraterShapes);\n    var thickness = 0;\n    var size;\n    if (obj.shapeAnnotationType === 'LineWidthArrowHead') {\n        thickness = obj.thickness;\n        size = new Size(thickness * 12, thickness * 12);\n    }\n    else {\n        thickness = obj.thickness <= 5 ? 5 : obj.thickness;\n        size = new Size(thickness * 2, thickness * 2);\n    }\n    element.transform = RotateTransform.Self;\n    setElementStype(obj, element);\n    element.style.fill = (obj.fillColor !== 'tranparent') ? obj.fillColor : 'white';\n    element.rotateAngle = angle;\n    element.data = getPath;\n    element.canMeasurePath = true;\n    element.width = size.width;\n    element.height = size.height;\n    if (obj.sourceDecoraterShapes === 'Butt') {\n        element.width = size.width - 10;\n        element.height = size.height + 10;\n    }\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} offsetPoint - Specified the annotation offset point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function getDecoratorElement(obj, offsetPoint, adjacentPoint, isSource) {\n    var decEle = new PathElement();\n    updateDecoratorElement(obj, decEle, offsetPoint, adjacentPoint, isSource);\n    return decEle;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation object.\n * @param {PointModel[]} pts - Specified the annotation point model array.\n * @returns {PointModel[]} - Returns the annotation point model array.\n */\nexport function clipDecorators(connector, pts) {\n    pts[0] = clipDecorator(connector, pts, true);\n    pts[pts.length - 1] = clipDecorator(connector, pts, false);\n    return pts;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel[]} points - Specified the annotation offset point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PointModel} - Returns the annotation point model.\n */\nexport function clipDecorator(connector, points, isSource) {\n    var point = { x: 0, y: 0 };\n    var start = { x: 0, y: 0 };\n    var end = { x: 0, y: 0 };\n    var length = points.length;\n    start = !isSource ? points[length - 1] : points[0];\n    end = !isSource ? points[length - 2] : points[1];\n    var len = Point.distancePoints(start, end);\n    len = (len === 0) ? 1 : len;\n    var width = connector.thickness;\n    point.x = (Math.round(start.x + width * (end.x - start.x) / len));\n    point.y = (Math.round(start.y + width * (end.y - start.y) / len));\n    var strokeWidth = 1;\n    point = Point.adjustPoint(point, end, true, (strokeWidth / 2));\n    return point;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\nexport function initDistanceLabel(obj, points, measure, pdfviewer) {\n    var labels = [];\n    var angle = Point.findAngle(points[0], points[1]);\n    var textele = textElement(obj, angle);\n    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n        textele.content = obj.notes;\n    }\n    else {\n        textele.content = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n    }\n    textele.rotateValue = { y: -10, angle: angle };\n    if (obj.enableShapeLabel === true) {\n        textele.style.strokeColor = obj.labelBorderColor;\n        textele.style.fill = obj.labelFillColor;\n        textele.style.fontSize = obj.fontSize;\n        textele.style.color = obj.fontColor;\n        textele.style.fontFamily = obj.fontFamily;\n    }\n    labels.push(textele);\n    return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the distance value.\n */\nexport function updateDistanceLabel(obj, points, measure) {\n    var distance;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_1 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_1 && !isNullOrUndefined(textElement_1.content)) {\n            distance = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n            textElement_1.content = distance;\n            textElement_1.childNodes[0].text = textElement_1.content;\n            textElement_1.refreshTextElement();\n        }\n    }\n    return distance;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the radius label value.\n */\nexport function updateRadiusLabel(obj, measure) {\n    var radius;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_2 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_2 && !isNullOrUndefined(textElement_2.content)) {\n            radius = measure.setConversion((obj.bounds.width / 2) * measure.pixelToPointFactor, obj);\n            textElement_2.content = radius;\n            if (textElement_2.childNodes.length === 2) {\n                textElement_2.childNodes[0].text = radius;\n                textElement_2.childNodes.splice(textElement_2.childNodes.length - 1, 1);\n            }\n            else {\n                textElement_2.childNodes[0].text = radius;\n            }\n            textElement_2.refreshTextElement();\n        }\n    }\n    return radius;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\nexport function initPerimeterLabel(obj, points, measure, pdfviewer) {\n    var labels = [];\n    var angle = Point.findAngle(points[0], points[1]);\n    var textele = textElement(obj, angle);\n    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n        textele.content = obj.notes;\n    }\n    else {\n        textele.content = measure.calculatePerimeter(obj);\n    }\n    if (obj.enableShapeLabel === true) {\n        textele.style.strokeColor = obj.labelBorderColor;\n        textele.style.fill = obj.labelFillColor;\n        textele.style.fontSize = obj.fontSize;\n        textele.style.color = obj.fontColor;\n        textele.style.fontFamily = obj.fontFamily;\n    }\n    textele.rotateValue = { y: -10, angle: angle };\n    labels.push(textele);\n    return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the perimeter label value.\n */\nexport function updatePerimeterLabel(obj, points, measure) {\n    var perimeter;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_3 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_3 && !isNullOrUndefined(textElement_3.content)) {\n            perimeter = measure.calculatePerimeter(obj);\n            textElement_3.content = perimeter;\n            textElement_3.childNodes[0].text = textElement_3.content;\n            textElement_3.refreshTextElement();\n        }\n    }\n    return perimeter;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nexport function removePerimeterLabel(obj) {\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_4 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_4 && !isNullOrUndefined(textElement_4.content)) {\n            obj.wrapper.children.splice(i, 1);\n        }\n    }\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nexport function updateCalibrateLabel(obj) {\n    if (obj.wrapper && obj.wrapper.children) {\n        for (var i = 0; i < obj.wrapper.children.length; i++) {\n            var textElement_5 = obj.wrapper.children[parseInt(i.toString(), 10)];\n            if (textElement_5 && !isNullOrUndefined(textElement_5.content)) {\n                textElement_5.content = obj.notes;\n                textElement_5.childNodes[0].text = textElement_5.content;\n                textElement_5.refreshTextElement();\n            }\n        }\n    }\n}\n/**\n * Used to find the path for polygon shapes\n *\n * @param {PointModel[]} collection - Specified the polygon annotaion points collection.\n * @hidden\n * @returns {string} - Returns the polygon annotation path.\n */\nexport function getPolygonPath(collection) {\n    var path = '';\n    var seg;\n    path = 'M' + collection[0].x + ' ' + collection[0].y;\n    var i;\n    for (i = 1; i < collection.length; i++) {\n        seg = collection[parseInt(i.toString(), 10)];\n        path += 'L' + seg.x + ' ' + seg.y;\n    }\n    path += 'Z';\n    return path;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {number} angle - Specified the annotaion rotation angle.\n * @hidden\n * @returns {TextElement} - Returns the annotation text element.\n */\nexport function textElement(obj, angle) {\n    var textele = new TextElement();\n    setElementStype(obj, textele);\n    textele.style.fill = 'transparent';\n    textele.id = randomId();\n    textele.horizontalAlignment = 'Center';\n    textele.rotateValue = { y: 10, angle: angle };\n    textele.verticalAlignment = 'Top';\n    textele.relativeMode = 'Object';\n    textele.setOffsetWithRespectToBounds(.5, .5, 'Absolute');\n    // eslint-disable-next-line\n    textele.offsetX;\n    textele.style.textWrapping = 'NoWrap';\n    return textele;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotaion leader points.\n * @hidden\n * @returns {PathElement[]} - Returns the annotation path elements.\n */\nexport function initLeaders(obj, points) {\n    var leaders = [];\n    var leader = initLeader(obj, points[0], points[1]);\n    leaders.push(leader);\n    leader = initLeader(obj, points[1], points[0], true);\n    leaders.push(leader);\n    return leaders;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} point1 - Specified the annotaion leader point1.\n * @param {PointModel} point2 - Specified the annotaion leader point2.\n * @param {boolean} isSecondLeader - Specified the is second leader or not.\n * @hidden\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function initLeader(obj, point1, point2, isSecondLeader) {\n    var element = new PathElement();\n    element.offsetX = point1.x;\n    element.offsetY = point1.y;\n    var angle = Point.findAngle(point1, point2);\n    var center = { x: (point1.x + point2.x) / 2, y: (point1.y + point2.y) / 2 };\n    var matrix = identityMatrix();\n    rotateMatrix(matrix, 0 - angle, center.x, center.y);\n    var rotatedPoint = transformPointByMatrix(matrix, point1);\n    var newPoint1 = { x: rotatedPoint.x, y: rotatedPoint.y - obj.leaderHeight };\n    matrix = identityMatrix();\n    rotateMatrix(matrix, angle, element.offsetX, element.offsetY);\n    rotatedPoint = transformPointByMatrix(matrix, newPoint1);\n    var finalPoint = { x: point1.x, y: point1.y };\n    element.offsetX = finalPoint.x;\n    element.offsetY = finalPoint.y;\n    element.transform = RotateTransform.Self;\n    var getPath = 'M' + point1.x + ',' + point1.y + ',L' + rotatedPoint.x + ',' + rotatedPoint.y + 'Z';\n    var size = new Size(0, obj.leaderHeight);\n    element.pivot.x = .5;\n    if (isSecondLeader) {\n        element.id = 'leader2_' + randomId();\n        element.pivot.y = 0;\n    }\n    else {\n        element.id = 'leader1_' + randomId();\n        element.pivot.y = 1;\n    }\n    setElementStype(obj, element);\n    element.rotateAngle = angle;\n    element.data = getPath;\n    element.canMeasurePath = true;\n    element.width = size.width;\n    element.height = size.height;\n    return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel} reference - Specified the pointer reference value.\n * @returns {boolean} - Returns true or false.\n */\nexport function isPointOverConnector(connector, reference) {\n    var vertexPoints = connector.vertexPoints;\n    if (!isNullOrUndefined(vertexPoints)) {\n        for (var i = 0; i < vertexPoints.length - 1; i++) {\n            var start = vertexPoints[parseInt(i.toString(), 10)];\n            var end = vertexPoints[i + 1];\n            var rect = Rect.toBounds([start, end]);\n            rect.Inflate(10);\n            if (rect.containsPoint(reference)) {\n                var intersectinPt = findNearestPoint(reference, start, end);\n                var segment1 = { x1: start.x, x2: end.x, y1: start.y, y2: end.y };\n                var segment2 = { x1: reference.x, x2: intersectinPt.x, y1: reference.y, y2: intersectinPt.y };\n                var intersectDetails = intersect3(segment1, segment2);\n                if (intersectDetails.enabled) {\n                    var distance = Point.findLength(reference, intersectDetails.intersectPt);\n                    if (Math.abs(distance) < 10) {\n                        return true;\n                    }\n                }\n                else {\n                    var rect_1 = Rect.toBounds([reference, reference]);\n                    rect_1.Inflate(3);\n                    if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {\n                        return true;\n                    }\n                }\n                if (Point.equals(reference, intersectinPt)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n/**\n * @param {PointModel} reference - Specified the pointer reference value.\n * @param {PointModel} start - Specified the pointer start value.\n * @param {PointModel} end - Specified the pointer end value.\n * @private\n * @returns {PointModel} - Returns annotation point model.\n */\nexport function findNearestPoint(reference, start, end) {\n    var shortestPoint;\n    var shortest = Point.findLength(start, reference);\n    var shortest1 = Point.findLength(end, reference);\n    if (shortest > shortest1) {\n        shortestPoint = end;\n    }\n    else {\n        shortestPoint = start;\n    }\n    var angleBWStAndEnd = Point.findAngle(start, end);\n    var angleBWStAndRef = Point.findAngle(shortestPoint, reference);\n    var r = Point.findLength(shortestPoint, reference);\n    var vaAngle = angleBWStAndRef + ((angleBWStAndEnd - angleBWStAndRef) * 2);\n    return {\n        x: (shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180)),\n        y: (shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180))\n    };\n}\n/**\n * @param {DecoratorShapes} shape - Specified the annotation decorator shapes.\n * @hidden\n * @returns {string} - Returns the annotation decorator shape value.\n */\nexport function getDecoratorShape(shape) {\n    // eslint-disable-next-line\n    return decoratorShapes[shape];\n}\nvar decoratorShapes = {\n    'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',\n    'Square': 'M0,0 L10,0 L10,10 L0,10 z',\n    'Fletch': 'M14.8,10c0,0-3.5,6,0.2,12c0,0-2.5-6-10.9-6C4.1,16,11.3,16,14.8,10z',\n    'OpenFetch': 'M6,17c-0.6,0-1-0.4-1-1s0.4-1,1-1c10.9,0,11-5,11-5' +\n        'c0-0.6,0.4-1,1-1s1,0.4,1,1C19,10.3,18.9,17,6,17C6,17,6,17,6,17z ' +\n        'M18,23c-0.5,0-1-0.4-1-1c0-0.2-0.3-5-11-5c-0.6,0-1-0.5-1-1s0.4-1,1-1c0,0,0,0,0,0' +\n        'c12.9,0,13,6.7,13,7    C19,22.6,18.6,23,18,23z',\n    'IndentedArrow': 'M17,10c0,0-4.5,5.5,0,12L5,16L17,10z',\n    'OutdentedArrow': 'M14.6,10c0,0,5.4,6,0,12L5,16L14.6,10z',\n    'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',\n    'Arrow': 'M15,10 L15,22 L5,16Z',\n    'Diamond': 'M12,23l-7-7l7-7l6.9,7L12,23z',\n    'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z',\n    'Butt': 'M0,0 L0,90'\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}