{"ast":null,"code":"import { isNullOrUndefined } from \"@syncfusion/ej2-base\";\nimport { FormFieldsBase } from './index';\nimport { PdfAnnotationFlag, PdfInkAnnotation, PdfPen, _PdfPath } from \"@syncfusion/ej2-pdf\";\nimport { Rect } from '@syncfusion/ej2-drawings';\n/**\n * SignatureBase\n *\n * @hidden\n */\nvar SignatureBase = /** @class */function () {\n  function SignatureBase(pdfViewer, pdfViewerBase) {\n    this.pdfViewer = pdfViewer;\n    this.pdfViewerBase = pdfViewerBase;\n  }\n  /**\n   * @private\n   * @param jsonObject\n   * @param loadedDocument\n   */\n  SignatureBase.prototype.saveSignatureData = function (jsonObject, loadedDocument) {\n    var formfields = new FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n    var signatureDetails = JSON.parse(jsonObject.signatureData);\n    if (!isNullOrUndefined(signatureDetails)) {\n      for (var i = 0; i < signatureDetails.length; i++) {\n        var pageData = signatureDetails[parseInt(i.toString(), 10)];\n        // Save signature as data\n        if (pageData.length > 0) {\n          for (var p = 0; p < pageData.length; p++) {\n            var data = pageData[parseInt(p.toString(), 10)];\n            var signatureType = data.hasOwnProperty(\"shapeAnnotationType\") && data[\"shapeAnnotationType\"] !== null ? data[\"shapeAnnotationType\"].toString() : null;\n            if (signatureType !== null && signatureType === 'SignatureText') {\n              formfields.drawFreeTextAnnotations(data, loadedDocument, true);\n            } else if (signatureType !== null && signatureType === 'SignatureImage') {\n              formfields.drawImage(data, loadedDocument, true);\n            } else {\n              var pageNumber = data.pageIndex;\n              var page = loadedDocument.getPage(pageNumber);\n              var rotateAngle = this.getRotateAngle(page.rotation.toString());\n              var size = page.size;\n              var pageWidth = size[0];\n              var pageHeight = size[1];\n              if (rotateAngle == 1 || rotateAngle == 3) {\n                pageHeight = size[0];\n                pageWidth = size[1];\n              } else {\n                pageHeight = size[0];\n                pageWidth = size[1];\n              }\n              var bounds = JSON.parse(data.bounds);\n              bounds = this.getSignatureBounds(bounds, this.convertPointToPixel(pageHeight), this.convertPointToPixel(pageWidth), rotateAngle);\n              var stampObjects = JSON.parse(data.data);\n              var left = this.convertPixelToPoint(bounds.left);\n              var top_1 = this.convertPixelToPoint(bounds.top);\n              var width = this.convertPixelToPoint(bounds.width);\n              var height = this.convertPixelToPoint(bounds.height);\n              var opacity = data.opacity;\n              var thickness = data.thickness;\n              var strokeColor = JSON.parse(data.strokeColor);\n              var color = [strokeColor.r, strokeColor.g, strokeColor.b];\n              var minimumX = -1;\n              var minimumY = -1;\n              var maximumX = -1;\n              var maximumY = -1;\n              for (var p_1 = 0; p_1 < stampObjects.length; p_1++) {\n                var value = stampObjects[parseInt(p_1.toString(), 10)];\n                if (minimumX == -1) {\n                  minimumX = value.x;\n                  minimumY = value.y;\n                  maximumX = value.x;\n                  maximumY = value.x;\n                } else {\n                  var point1 = value.x;\n                  var point2 = value.y;\n                  if (minimumX >= point1) {\n                    minimumX = point1;\n                  }\n                  if (minimumY >= point2) {\n                    minimumY = point2;\n                  }\n                  if (maximumX <= point1) {\n                    maximumX = point1;\n                  }\n                  if (maximumY <= point2) {\n                    maximumY = point2;\n                  }\n                }\n              }\n              var newDifferenceX = maximumX - minimumX;\n              var newDifferenceY = maximumY - minimumY;\n              var newPoint1 = [0, 0];\n              var loadedPage = loadedDocument.getPage(pageNumber);\n              var graphics = null;\n              if (loadedPage != null) {\n                graphics = loadedPage.graphics;\n                graphics.save();\n                graphics.setTransparency(opacity);\n                graphics.translateTransform(left, top_1);\n              }\n              var colors = new PdfPen(color, width);\n              colors._width = thickness;\n              if (stampObjects.length > 0) {\n                var dataPath = new _PdfPath();\n                for (var j = 0; j < stampObjects.length; j++) {\n                  var value = stampObjects[parseInt(j.toString(), 10)];\n                  var path = value.command.toString();\n                  var differenceX = newDifferenceX / width;\n                  var differenceY = newDifferenceY / height;\n                  var newX = (value.x - minimumX) / differenceX;\n                  var currentY = (value.y - minimumY) / differenceY;\n                  if (path == \"M\") {\n                    if (j != 0) {\n                      page.graphics._drawPath(dataPath, colors, null);\n                      dataPath = new _PdfPath();\n                    }\n                    newPoint1 = [newX, currentY];\n                    if (!isNullOrUndefined(graphics)) {\n                      dataPath._addLine(newX, currentY, newX, currentY);\n                    }\n                  } else if (path = 'L') {\n                    var newPoint2 = [newX, currentY];\n                    if (graphics != null) {\n                      // Removed this line to fix the issue EJ2-60295\n                      // graphics.DrawLine(colors, newpoint1, newpoint2);\n                      dataPath._addLine(newPoint1[0], newPoint1[1], newPoint2[0], newPoint2[1]);\n                    }\n                    newPoint1 = newPoint2;\n                  }\n                  if (j == stampObjects.length - 1) {\n                    page.graphics._drawPath(dataPath, colors, null);\n                  }\n                }\n              }\n              if (graphics != null) {\n                graphics.restore();\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * getSignatureBounds\n   */\n  SignatureBase.prototype.getSignatureBounds = function (bounds, pageHeight, pageWidth, rotateAngle) {\n    var bound;\n    if (rotateAngle == 0) {\n      bound = {\n        \"left\": bounds.left,\n        \"top\": bounds.top,\n        \"width\": bounds.width,\n        \"height\": bounds.height\n      };\n    } else if (rotateAngle == 1) {\n      bound = {\n        \"left\": pageWidth - bounds.top - bounds.height,\n        \"top\": bounds.left,\n        \"width\": bounds.height,\n        \"height\": bounds.width\n      };\n    } else if (rotateAngle == 2) {\n      bound = {\n        \"left\": pageWidth - bounds.left - bounds.width,\n        \"top\": pageHeight - bounds.top - bounds.height,\n        \"width\": bounds.width,\n        \"height\": bounds.height\n      };\n    } else if (rotateAngle == 3) {\n      bound = {\n        \"left\": bounds.top,\n        \"top\": pageHeight - bounds.width,\n        \"width\": bounds.height,\n        \"height\": bounds.width\n      };\n    }\n    return bound;\n  };\n  /**\n   * @private\n   * @param jsonObject\n   * @param loadedDocument\n   */\n  SignatureBase.prototype.saveSignatureAsAnnotatation = function (jsonObject, loadedDocument) {\n    var formfields = new FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n    var signatureDetails = JSON.parse(jsonObject.signatureData);\n    if (!isNullOrUndefined(signatureDetails)) {\n      for (var i = 0; i < signatureDetails.length; i++) {\n        var pageData = signatureDetails[parseInt(i.toString(), 10)];\n        // Save signature as data\n        if (pageData.length > 0) {\n          for (var p = 0; p < pageData.length; p++) {\n            var formfields_1 = new FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n            var signatureAnnotation = pageData[parseInt(p.toString(), 10)];\n            var signatureType = signatureAnnotation.hasOwnProperty(\"shapeAnnotationType\") && signatureAnnotation[\"shapeAnnotationType\"] !== null ? signatureAnnotation[\"shapeAnnotationType\"].toString() : null;\n            if (signatureType !== null && signatureType === 'SignatureText') {\n              formfields_1.drawFreeTextAnnotations(signatureAnnotation, loadedDocument, false);\n            } else if (signatureType !== null && signatureType === 'SignatureImage') {\n              formfields_1.drawImage(signatureAnnotation, loadedDocument, false);\n            } else {\n              var bounds = JSON.parse(signatureAnnotation.bounds);\n              var stampObjects = JSON.parse(signatureAnnotation.data);\n              var left = this.convertPixelToPoint(bounds.left);\n              var top_2 = this.convertPixelToPoint(bounds.top);\n              var width = this.convertPixelToPoint(bounds.width);\n              var height = this.convertPixelToPoint(bounds.height);\n              var pageNumber = signatureAnnotation.pageIndex;\n              var page = loadedDocument.getPage(pageNumber);\n              // let cropX = 0;\n              // let cropY = 0;\n              // if(page.cropBox.x)\n              var opacity = signatureAnnotation.opacity;\n              var thickness = signatureAnnotation.thickness;\n              var strokeColor = JSON.parse(signatureAnnotation.strokeColor);\n              var color = [strokeColor.r, strokeColor.g, strokeColor.b];\n              var minimumX = -1;\n              var minimumY = -1;\n              var maximumX = -1;\n              var maximumY = -1;\n              for (var p_2 = 0; p_2 < stampObjects.length; p_2++) {\n                var value = stampObjects[parseInt(p_2.toString(), 10)];\n                if (minimumX == -1) {\n                  minimumX = value.x;\n                  minimumY = value.y;\n                  maximumX = value.x;\n                  maximumY = value.x;\n                } else {\n                  var point1 = value.x;\n                  var point2 = value.y;\n                  if (minimumX >= point1) {\n                    minimumX = point1;\n                  }\n                  if (minimumY >= point2) {\n                    minimumY = point2;\n                  }\n                  if (maximumX <= point1) {\n                    maximumX = point1;\n                  }\n                  if (maximumY <= point2) {\n                    maximumY = point2;\n                  }\n                }\n              }\n              var newDifferenceX = maximumX - minimumX;\n              var newDifferenceY = maximumY - minimumY;\n              var linePoints = [];\n              var isNewValues = 0;\n              for (var j = 0; j < stampObjects.length; j++) {\n                var element = stampObjects[parseInt(j.toString(), 10)];\n                var value = stampObjects[parseInt(j.toString(), 10)];\n                var path = value.command.toString();\n                if (path == \"M\" && j !== 0) {\n                  isNewValues = j;\n                  break;\n                }\n                var differenceX = newDifferenceX / width;\n                var differenceY = newDifferenceY / height;\n                linePoints.push((value.x - minimumX) / differenceX + left);\n                var newX = (value.y - minimumY) / differenceY;\n                linePoints.push(loadedDocument.getPage(pageNumber).size[1] - newX - top_2);\n              }\n              var highestY = 1;\n              for (var k = 0; k < linePoints.length - 1; k++) {\n                if (linePoints[parseInt(k.toString(), 10)] > highestY) {\n                  highestY = linePoints[parseInt(k.toString(), 10)];\n                }\n              }\n              var rectangle = new Rect(left, top_2, width, height);\n              var inkAnnotation = new PdfInkAnnotation([rectangle.x, rectangle.y, rectangle.width, rectangle.height], linePoints);\n              var bound = new Rect(inkAnnotation.bounds.x, inkAnnotation.bounds.y, inkAnnotation.bounds.width, inkAnnotation.bounds.height);\n              inkAnnotation.bounds = bound;\n              inkAnnotation.color = color;\n              linePoints = [];\n              for (var i_1 = isNewValues; i_1 < stampObjects.length; i_1++) {\n                var val = stampObjects[parseInt(i_1.toString(), 10)];\n                var path = val[\"command\"].toString();\n                if (path === \"M\" && i_1 !== isNewValues) {\n                  inkAnnotation.inkPointsCollection.push(linePoints);\n                  linePoints = [];\n                }\n                var differenceX = newDifferenceX / width;\n                var differenceY = newDifferenceY / height;\n                linePoints.push((parseFloat(val[\"x\"].toString()) - minimumX) / differenceX + left);\n                var newX = (parseFloat(val[\"y\"].toString()) - minimumY) / differenceY;\n                linePoints.push(loadedDocument.getPage(pageNumber).size[1] - newX - top_2);\n              }\n              if (linePoints.length > 0) {\n                inkAnnotation.inkPointsCollection.push(linePoints);\n              }\n              inkAnnotation.border.width = thickness;\n              inkAnnotation.opacity = opacity;\n              inkAnnotation._dictionary.set('NM', signatureAnnotation.signatureName.toString());\n              inkAnnotation._annotFlags = PdfAnnotationFlag.print;\n              if (signatureAnnotation.hasOwnProperty('author') && signatureAnnotation['author'] !== null) {\n                var author = signatureAnnotation['author'].toString();\n                if (author !== 'Guest') {\n                  inkAnnotation.author = author;\n                }\n              }\n              page.annotations.add(inkAnnotation);\n            }\n          }\n        }\n      }\n    }\n  };\n  SignatureBase.prototype.convertPointToPixel = function (number) {\n    return number * 96 / 72;\n  };\n  SignatureBase.prototype.convertPixelToPoint = function (value) {\n    return value * (72 / 96);\n  };\n  SignatureBase.prototype.getRotateAngle = function (angleString) {\n    var angle = 0;\n    switch (angleString) {\n      case 'RotateAngle0':\n        angle = 0;\n        break;\n      case 'RotateAngle180':\n        angle = 2;\n        break;\n      case 'RotateAngle270':\n        angle = 3;\n        break;\n      case 'RotateAngle90':\n        angle = 1;\n        break;\n    }\n    return angle;\n  };\n  return SignatureBase;\n}();\nexport { SignatureBase };","map":{"version":3,"names":["isNullOrUndefined","FormFieldsBase","PdfAnnotationFlag","PdfInkAnnotation","PdfPen","_PdfPath","Rect","SignatureBase","pdfViewer","pdfViewerBase","prototype","saveSignatureData","jsonObject","loadedDocument","formfields","signatureDetails","JSON","parse","signatureData","i","length","pageData","parseInt","toString","p","data","signatureType","hasOwnProperty","drawFreeTextAnnotations","drawImage","pageNumber","pageIndex","page","getPage","rotateAngle","getRotateAngle","rotation","size","pageWidth","pageHeight","bounds","getSignatureBounds","convertPointToPixel","stampObjects","left","convertPixelToPoint","top_1","top","width","height","opacity","thickness","strokeColor","color","r","g","b","minimumX","minimumY","maximumX","maximumY","p_1","value","x","y","point1","point2","newDifferenceX","newDifferenceY","newPoint1","loadedPage","graphics","save","setTransparency","translateTransform","colors","_width","dataPath","j","path","command","differenceX","differenceY","newX","currentY","_drawPath","_addLine","newPoint2","restore","bound","saveSignatureAsAnnotatation","formfields_1","signatureAnnotation","top_2","p_2","linePoints","isNewValues","element","push","highestY","k","rectangle","inkAnnotation","i_1","val","inkPointsCollection","parseFloat","border","_dictionary","set","signatureName","_annotFlags","print","author","annotations","add","number","angleString","angle"],"sources":["/Users/saleem/Desktop/KClient/Web App/Ver_3.6/User Interface/website_Source files/node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdf-base/signature-base.js"],"sourcesContent":["import { isNullOrUndefined } from \"@syncfusion/ej2-base\";\nimport { FormFieldsBase } from './index';\nimport { PdfAnnotationFlag, PdfInkAnnotation, PdfPen, _PdfPath } from \"@syncfusion/ej2-pdf\";\nimport { Rect } from '@syncfusion/ej2-drawings';\n/**\n * SignatureBase\n *\n * @hidden\n */\nvar SignatureBase = /** @class */ (function () {\n    function SignatureBase(pdfViewer, pdfViewerBase) {\n        this.pdfViewer = pdfViewer;\n        this.pdfViewerBase = pdfViewerBase;\n    }\n    /**\n     * @private\n     * @param jsonObject\n     * @param loadedDocument\n     */\n    SignatureBase.prototype.saveSignatureData = function (jsonObject, loadedDocument) {\n        var formfields = new FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n        var signatureDetails = JSON.parse(jsonObject.signatureData);\n        if (!isNullOrUndefined(signatureDetails)) {\n            for (var i = 0; i < signatureDetails.length; i++) {\n                var pageData = signatureDetails[parseInt(i.toString(), 10)];\n                // Save signature as data\n                if (pageData.length > 0) {\n                    for (var p = 0; p < pageData.length; p++) {\n                        var data = pageData[parseInt(p.toString(), 10)];\n                        var signatureType = data.hasOwnProperty(\"shapeAnnotationType\") && data[\"shapeAnnotationType\"] !== null\n                            ? data[\"shapeAnnotationType\"].toString()\n                            : null;\n                        if (signatureType !== null && signatureType === 'SignatureText') {\n                            formfields.drawFreeTextAnnotations(data, loadedDocument, true);\n                        }\n                        else if (signatureType !== null && signatureType === 'SignatureImage') {\n                            formfields.drawImage(data, loadedDocument, true);\n                        }\n                        else {\n                            var pageNumber = data.pageIndex;\n                            var page = loadedDocument.getPage(pageNumber);\n                            var rotateAngle = this.getRotateAngle(page.rotation.toString());\n                            var size = page.size;\n                            var pageWidth = size[0];\n                            var pageHeight = size[1];\n                            if (rotateAngle == 1 || rotateAngle == 3) {\n                                pageHeight = size[0];\n                                pageWidth = size[1];\n                            }\n                            else {\n                                pageHeight = size[0];\n                                pageWidth = size[1];\n                            }\n                            var bounds = JSON.parse(data.bounds);\n                            bounds = this.getSignatureBounds(bounds, this.convertPointToPixel(pageHeight), this.convertPointToPixel(pageWidth), rotateAngle);\n                            var stampObjects = JSON.parse(data.data);\n                            var left = this.convertPixelToPoint(bounds.left);\n                            var top_1 = this.convertPixelToPoint(bounds.top);\n                            var width = this.convertPixelToPoint(bounds.width);\n                            var height = this.convertPixelToPoint(bounds.height);\n                            var opacity = data.opacity;\n                            var thickness = data.thickness;\n                            var strokeColor = JSON.parse(data.strokeColor);\n                            var color = [strokeColor.r, strokeColor.g, strokeColor.b];\n                            var minimumX = -1;\n                            var minimumY = -1;\n                            var maximumX = -1;\n                            var maximumY = -1;\n                            for (var p_1 = 0; p_1 < stampObjects.length; p_1++) {\n                                var value = stampObjects[parseInt(p_1.toString(), 10)];\n                                if (minimumX == -1) {\n                                    minimumX = value.x;\n                                    minimumY = value.y;\n                                    maximumX = value.x;\n                                    maximumY = value.x;\n                                }\n                                else {\n                                    var point1 = value.x;\n                                    var point2 = value.y;\n                                    if (minimumX >= point1) {\n                                        minimumX = point1;\n                                    }\n                                    if (minimumY >= point2) {\n                                        minimumY = point2;\n                                    }\n                                    if (maximumX <= point1) {\n                                        maximumX = point1;\n                                    }\n                                    if (maximumY <= point2) {\n                                        maximumY = point2;\n                                    }\n                                }\n                            }\n                            var newDifferenceX = maximumX - minimumX;\n                            var newDifferenceY = maximumY - minimumY;\n                            var newPoint1 = [0, 0];\n                            var loadedPage = loadedDocument.getPage(pageNumber);\n                            var graphics = null;\n                            if (loadedPage != null) {\n                                graphics = loadedPage.graphics;\n                                graphics.save();\n                                graphics.setTransparency(opacity);\n                                graphics.translateTransform(left, top_1);\n                            }\n                            var colors = new PdfPen(color, width);\n                            colors._width = thickness;\n                            if (stampObjects.length > 0) {\n                                var dataPath = new _PdfPath();\n                                for (var j = 0; j < stampObjects.length; j++) {\n                                    var value = stampObjects[parseInt(j.toString(), 10)];\n                                    var path = value.command.toString();\n                                    var differenceX = ((newDifferenceX) / width);\n                                    var differenceY = ((newDifferenceY) / height);\n                                    var newX = ((value.x - minimumX) / differenceX);\n                                    var currentY = ((value.y - minimumY) / differenceY);\n                                    if (path == \"M\") {\n                                        if (j != 0) {\n                                            page.graphics._drawPath(dataPath, colors, null);\n                                            dataPath = new _PdfPath();\n                                        }\n                                        newPoint1 = [newX, currentY];\n                                        if (!isNullOrUndefined(graphics)) {\n                                            dataPath._addLine(newX, currentY, newX, currentY);\n                                        }\n                                    }\n                                    else if (path = 'L') {\n                                        var newPoint2 = [newX, currentY];\n                                        if (graphics != null) {\n                                            // Removed this line to fix the issue EJ2-60295\n                                            // graphics.DrawLine(colors, newpoint1, newpoint2);\n                                            dataPath._addLine(newPoint1[0], newPoint1[1], newPoint2[0], newPoint2[1]);\n                                        }\n                                        newPoint1 = newPoint2;\n                                    }\n                                    if (j == stampObjects.length - 1) {\n                                        page.graphics._drawPath(dataPath, colors, null);\n                                    }\n                                }\n                            }\n                            if (graphics != null) {\n                                graphics.restore();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * getSignatureBounds\n     */\n    SignatureBase.prototype.getSignatureBounds = function (bounds, pageHeight, pageWidth, rotateAngle) {\n        var bound;\n        if (rotateAngle == 0) {\n            bound = { \"left\": bounds.left, \"top\": bounds.top, \"width\": bounds.width, \"height\": bounds.height };\n        }\n        else if (rotateAngle == 1) {\n            bound = { \"left\": (pageWidth - bounds.top - bounds.height), \"top\": bounds.left, \"width\": bounds.height, \"height\": bounds.width };\n        }\n        else if (rotateAngle == 2) {\n            bound = { \"left\": (pageWidth - bounds.left - bounds.width), \"top\": (pageHeight - bounds.top - bounds.height), \"width\": bounds.width, \"height\": bounds.height };\n        }\n        else if (rotateAngle == 3) {\n            bound = { \"left\": bounds.top, \"top\": (pageHeight - bounds.width), \"width\": bounds.height, \"height\": bounds.width };\n        }\n        return bound;\n    };\n    /**\n     * @private\n     * @param jsonObject\n     * @param loadedDocument\n     */\n    SignatureBase.prototype.saveSignatureAsAnnotatation = function (jsonObject, loadedDocument) {\n        var formfields = new FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n        var signatureDetails = JSON.parse(jsonObject.signatureData);\n        if (!isNullOrUndefined(signatureDetails)) {\n            for (var i = 0; i < signatureDetails.length; i++) {\n                var pageData = signatureDetails[parseInt(i.toString(), 10)];\n                // Save signature as data\n                if (pageData.length > 0) {\n                    for (var p = 0; p < pageData.length; p++) {\n                        var formfields_1 = new FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n                        var signatureAnnotation = pageData[parseInt(p.toString(), 10)];\n                        var signatureType = signatureAnnotation.hasOwnProperty(\"shapeAnnotationType\") && signatureAnnotation[\"shapeAnnotationType\"] !== null\n                            ? signatureAnnotation[\"shapeAnnotationType\"].toString()\n                            : null;\n                        if (signatureType !== null && signatureType === 'SignatureText') {\n                            formfields_1.drawFreeTextAnnotations(signatureAnnotation, loadedDocument, false);\n                        }\n                        else if (signatureType !== null && signatureType === 'SignatureImage') {\n                            formfields_1.drawImage(signatureAnnotation, loadedDocument, false);\n                        }\n                        else {\n                            var bounds = JSON.parse(signatureAnnotation.bounds);\n                            var stampObjects = JSON.parse(signatureAnnotation.data);\n                            var left = this.convertPixelToPoint(bounds.left);\n                            var top_2 = this.convertPixelToPoint(bounds.top);\n                            var width = this.convertPixelToPoint(bounds.width);\n                            var height = this.convertPixelToPoint(bounds.height);\n                            var pageNumber = signatureAnnotation.pageIndex;\n                            var page = loadedDocument.getPage(pageNumber);\n                            // let cropX = 0;\n                            // let cropY = 0;\n                            // if(page.cropBox.x)\n                            var opacity = signatureAnnotation.opacity;\n                            var thickness = signatureAnnotation.thickness;\n                            var strokeColor = JSON.parse(signatureAnnotation.strokeColor);\n                            var color = [strokeColor.r, strokeColor.g, strokeColor.b];\n                            var minimumX = -1;\n                            var minimumY = -1;\n                            var maximumX = -1;\n                            var maximumY = -1;\n                            for (var p_2 = 0; p_2 < stampObjects.length; p_2++) {\n                                var value = stampObjects[parseInt(p_2.toString(), 10)];\n                                if (minimumX == -1) {\n                                    minimumX = value.x;\n                                    minimumY = value.y;\n                                    maximumX = value.x;\n                                    maximumY = value.x;\n                                }\n                                else {\n                                    var point1 = value.x;\n                                    var point2 = value.y;\n                                    if (minimumX >= point1) {\n                                        minimumX = point1;\n                                    }\n                                    if (minimumY >= point2) {\n                                        minimumY = point2;\n                                    }\n                                    if (maximumX <= point1) {\n                                        maximumX = point1;\n                                    }\n                                    if (maximumY <= point2) {\n                                        maximumY = point2;\n                                    }\n                                }\n                            }\n                            var newDifferenceX = maximumX - minimumX;\n                            var newDifferenceY = maximumY - minimumY;\n                            var linePoints = [];\n                            var isNewValues = 0;\n                            for (var j = 0; j < stampObjects.length; j++) {\n                                var element = stampObjects[parseInt(j.toString(), 10)];\n                                var value = stampObjects[parseInt(j.toString(), 10)];\n                                var path = value.command.toString();\n                                if (path == \"M\" && j !== 0) {\n                                    isNewValues = j;\n                                    break;\n                                }\n                                var differenceX = ((newDifferenceX) / width);\n                                var differenceY = ((newDifferenceY) / height);\n                                linePoints.push(((value.x - minimumX) / differenceX) + left);\n                                var newX = ((value.y - minimumY) / differenceY);\n                                linePoints.push(loadedDocument.getPage(pageNumber).size[1] - newX - top_2);\n                            }\n                            var highestY = 1;\n                            for (var k = 0; k < linePoints.length - 1; k++) {\n                                if (linePoints[parseInt(k.toString(), 10)] > highestY) {\n                                    highestY = linePoints[parseInt(k.toString(), 10)];\n                                }\n                            }\n                            var rectangle = new Rect(left, top_2, width, height);\n                            var inkAnnotation = new PdfInkAnnotation([rectangle.x, rectangle.y, rectangle.width, rectangle.height], linePoints);\n                            var bound = new Rect(inkAnnotation.bounds.x, inkAnnotation.bounds.y, inkAnnotation.bounds.width, inkAnnotation.bounds.height);\n                            inkAnnotation.bounds = bound;\n                            inkAnnotation.color = color;\n                            linePoints = [];\n                            for (var i_1 = isNewValues; i_1 < stampObjects.length; i_1++) {\n                                var val = stampObjects[parseInt(i_1.toString(), 10)];\n                                var path = val[\"command\"].toString();\n                                if (path === \"M\" && i_1 !== isNewValues) {\n                                    inkAnnotation.inkPointsCollection.push(linePoints);\n                                    linePoints = [];\n                                }\n                                var differenceX = newDifferenceX / width;\n                                var differenceY = newDifferenceY / height;\n                                linePoints.push((parseFloat(val[\"x\"].toString()) - minimumX) / differenceX + left);\n                                var newX = (parseFloat(val[\"y\"].toString()) - minimumY) / differenceY;\n                                linePoints.push(loadedDocument.getPage(pageNumber).size[1] - newX - top_2);\n                            }\n                            if (linePoints.length > 0) {\n                                inkAnnotation.inkPointsCollection.push(linePoints);\n                            }\n                            inkAnnotation.border.width = thickness;\n                            inkAnnotation.opacity = opacity;\n                            inkAnnotation._dictionary.set('NM', signatureAnnotation.signatureName.toString());\n                            inkAnnotation._annotFlags = PdfAnnotationFlag.print;\n                            if (signatureAnnotation.hasOwnProperty('author') && signatureAnnotation['author'] !== null) {\n                                var author = signatureAnnotation['author'].toString();\n                                if (author !== 'Guest') {\n                                    inkAnnotation.author = author;\n                                }\n                            }\n                            page.annotations.add(inkAnnotation);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    SignatureBase.prototype.convertPointToPixel = function (number) {\n        return number * 96 / 72;\n    };\n    SignatureBase.prototype.convertPixelToPoint = function (value) {\n        return (value * (72 / 96));\n    };\n    SignatureBase.prototype.getRotateAngle = function (angleString) {\n        var angle = 0;\n        switch (angleString) {\n            case 'RotateAngle0':\n                angle = 0;\n                break;\n            case 'RotateAngle180':\n                angle = 2;\n                break;\n            case 'RotateAngle270':\n                angle = 3;\n                break;\n            case 'RotateAngle90':\n                angle = 1;\n                break;\n        }\n        return angle;\n    };\n    return SignatureBase;\n}());\nexport { SignatureBase };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}