{"ast":null,"code":"import require$$0, { memo, Children, useMemo, useRef, useCallback, useEffect, useState } from \"react\";\nimport mergeRefs from \"react-merge-refs\";\nimport useResizeObserver from \"use-resize-observer\";\nimport classNames from \"classnames\";\nconst getTurn = selected => {\n  let turn = selected % 1;\n  if (turn >= 0.5) {\n    turn -= 1;\n  }\n  return turn;\n};\nconst container$1 = \"_container_1v3jh_1\";\nvar classes$1 = {\n  container: container$1\n};\nvar jsxRuntime = {\n  exports: {}\n};\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f = require$$0,\n  k = Symbol.for(\"react.element\"),\n  l = Symbol.for(\"react.fragment\"),\n  m = Object.prototype.hasOwnProperty,\n  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,\n  p = {\n    key: true,\n    ref: true,\n    __self: true,\n    __source: true\n  };\nfunction q(c, a, g) {\n  var b,\n    d = {},\n    e = null,\n    h = null;\n  g !== void 0 && (e = \"\" + g);\n  a.key !== void 0 && (e = \"\" + a.key);\n  a.ref !== void 0 && (h = a.ref);\n  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n  if (c && c.defaultProps) for (b in a = c.defaultProps, a) d[b] === void 0 && (d[b] = a[b]);\n  return {\n    $$typeof: k,\n    type: c,\n    key: e,\n    ref: h,\n    props: d,\n    _owner: n.current\n  };\n}\nreactJsxRuntime_production_min.Fragment = l;\nreactJsxRuntime_production_min.jsx = q;\nreactJsxRuntime_production_min.jsxs = q;\n{\n  jsxRuntime.exports = reactJsxRuntime_production_min;\n}\nconst jsx = jsxRuntime.exports.jsx;\nconst jsxs = jsxRuntime.exports.jsxs;\nconst Fragment = jsxRuntime.exports.Fragment;\nconst defaultShadowBackground = \"rgb(0, 0, 0, 0.25)\";\nconst getFlippingPagesShadow = (background = defaultShadowBackground) => {\n  const _FlippingPagesShadow = props => {\n    const {\n      selected,\n      willChange\n    } = props;\n    const turn = getTurn(selected);\n    return /* @__PURE__ */jsx(\"div\", {\n      className: classes$1.container,\n      style: {\n        background,\n        opacity: Math.abs(turn) * 2,\n        willChange: willChange ? \"opacity\" : void 0\n      }\n    });\n  };\n  return memo(_FlippingPagesShadow);\n};\nconst getTransform = (direction, turn) => {\n  switch (direction) {\n    case \"bottom-to-top\":\n      return `rotateX(${turn * 180}deg)`;\n    case \"top-to-bottom\":\n      return `rotateX(${turn * -180}deg)`;\n    case \"left-to-right\":\n      return `rotateY(${turn * 180}deg)`;\n    case \"right-to-left\":\n      return `rotateY(${turn * -180}deg)`;\n  }\n};\nconst container = \"_container_1veud_1\";\nconst fullPage = \"_fullPage_1veud_7\";\nconst prevPage = \"_prevPage_1veud_8\";\nconst nextPage = \"_nextPage_1veud_9\";\nconst shadow = \"_shadow_1veud_97\";\nvar classes = {\n  container,\n  fullPage,\n  prevPage,\n  nextPage,\n  \"bottom-to-top\": \"_bottom-to-top_1veud_13\",\n  \"top-to-bottom\": \"_top-to-bottom_1veud_13\",\n  \"left-to-right\": \"_left-to-right_1veud_17\",\n  \"right-to-left\": \"_right-to-left_1veud_17\",\n  shadow\n};\nconst _FlippingPagesCore = props => {\n  const {\n    containerProps,\n    containerRef,\n    direction,\n    selected,\n    shadowBackground\n  } = props;\n  const children = Children.toArray(props.children);\n  const ShadowComponent = useMemo(() => props.shadowComponent ? props.shadowComponent : getFlippingPagesShadow(shadowBackground), [shadowBackground, props.shadowComponent]);\n  const turn = getTurn(selected);\n  const willChange = !!props.willChange;\n  return /* @__PURE__ */jsxs(\"div\", {\n    ...containerProps,\n    ref: containerRef,\n    className: classNames(classes.container, containerProps?.className),\n    children: [/* @__PURE__ */jsx(\"div\", {\n      className: classNames({\n        [classes.fullPage]: turn === 0,\n        [classes.prevPage]: turn > 0,\n        [classes.nextPage]: turn < 0\n      }, classes[direction]),\n      children: /* @__PURE__ */jsx(\"div\", {\n        children: children[Math.round(selected)]\n      })\n    }), turn !== 0 && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        children: /* @__PURE__ */jsx(\"div\", {\n          children: children[turn > 0 ? Math.ceil(selected) : Math.floor(selected)]\n        })\n      }), /* @__PURE__ */jsxs(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        style: {\n          transform: getTransform(direction, turn),\n          willChange: willChange ? \"transform\" : void 0\n        },\n        children: [/* @__PURE__ */jsx(\"div\", {\n          children: children[Math.round(selected)]\n        }), /* @__PURE__ */jsx(\"div\", {\n          className: classes.shadow,\n          children: /* @__PURE__ */jsx(ShadowComponent, {\n            selected,\n            willChange\n          })\n        })]\n      })]\n    })]\n  });\n};\nconst FlippingPagesCore = memo(_FlippingPagesCore);\nconst defaultPerspectiveMultiplier = 2;\nconst _FlippingPagesWithPerspective = props => {\n  const {\n    direction,\n    perspectiveMultiplier = defaultPerspectiveMultiplier\n  } = props;\n  const {\n    ref,\n    height,\n    width\n  } = useResizeObserver();\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [ref, props.containerRef]);\n  const perspective = useMemo(() => {\n    switch (direction) {\n      case \"bottom-to-top\":\n      case \"top-to-bottom\":\n        if (!height) {\n          return;\n        }\n        return height * perspectiveMultiplier;\n      case \"left-to-right\":\n      case \"right-to-left\":\n        if (!width) {\n          return;\n        }\n        return width * perspectiveMultiplier;\n    }\n  }, [direction, perspectiveMultiplier, height, width]);\n  const containerProps = useMemo(() => ({\n    ...props.containerProps,\n    style: {\n      perspective,\n      ...props.containerProps?.style\n    }\n  }), [props.containerProps, perspective]);\n  return /* @__PURE__ */jsx(FlippingPagesCore, {\n    ...props,\n    containerProps,\n    containerRef\n  });\n};\nconst FlippingPagesWithPerspective = memo(_FlippingPagesWithPerspective);\nconst useAnimation = options => {\n  const {\n    callback,\n    onEnd,\n    onStart\n  } = options;\n  const rafIdRef = useRef();\n  const startTimeRef = useRef();\n  const update = useCallback(timestamp => {\n    if (!startTimeRef.current) {\n      startTimeRef.current = timestamp;\n      rafIdRef.current = requestAnimationFrame(update);\n      return;\n    }\n    const timeElapsed = timestamp - startTimeRef.current;\n    const end = callback(timeElapsed);\n    if (end) {\n      rafIdRef.current = void 0;\n      onEnd();\n    } else {\n      rafIdRef.current = requestAnimationFrame(update);\n    }\n  }, [callback, onEnd]);\n  const start = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n    } else {\n      onStart();\n    }\n    startTimeRef.current = void 0;\n    rafIdRef.current = requestAnimationFrame(update);\n  }, [onStart, update]);\n  const stop = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n      rafIdRef.current = void 0;\n      onEnd();\n    }\n  }, [onEnd]);\n  useEffect(() => {\n    return () => {\n      if (rafIdRef.current) {\n        cancelAnimationFrame(rafIdRef.current);\n      }\n    };\n  }, []);\n  return {\n    start,\n    stop\n  };\n};\nconst defaultAnimationDuration = 400;\nconst _FlippingPagesWithAnimation = props => {\n  const {\n    animationDuration = defaultAnimationDuration,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn\n  } = props;\n  const [animationRunning, setAnimationRunning] = useState(false);\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return animationRunning ? true : void 0;\n  }, [props.willChange, animationRunning]);\n  const startSelectedRef = useRef(0);\n  const [selected, setSelected] = useState(props.selected);\n  const onStart = useCallback(() => {\n    setAnimationRunning(true);\n    onAnimationStart?.();\n  }, [onAnimationStart]);\n  const onEnd = useCallback(() => {\n    setAnimationRunning(false);\n    onAnimationEnd?.();\n  }, [onAnimationEnd]);\n  const updateAnimation = useCallback(timeElapsed => {\n    const maxSelectedChange = props.selected - startSelectedRef.current;\n    const selectedChange = Math.sign(maxSelectedChange) * timeElapsed / animationDuration;\n    if (Math.abs(selectedChange) >= Math.abs(maxSelectedChange)) {\n      setSelected(props.selected);\n      return true;\n    }\n    const newSelected = startSelectedRef.current + selectedChange;\n    setSelected(newSelected);\n    onAnimationTurn?.(newSelected);\n    return false;\n  }, [animationDuration, onAnimationTurn, props.selected]);\n  const {\n    start,\n    stop\n  } = useAnimation({\n    callback: updateAnimation,\n    onEnd,\n    onStart\n  });\n  useEffect(() => {\n    if (selected === props.selected) {\n      stop();\n      return;\n    }\n    if (!animationDuration) {\n      stop();\n      setSelected(props.selected);\n      return;\n    }\n    startSelectedRef.current = selected;\n    start();\n  }, [animationDuration, props.selected]);\n  return /* @__PURE__ */jsx(FlippingPagesWithPerspective, {\n    ...props,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithAnimation = memo(_FlippingPagesWithAnimation);\nconst useMergeEvents = (...eventHandlers) => useCallback(event => {\n  for (const eventHandler of eventHandlers) {\n    eventHandler?.(event);\n  }\n}, eventHandlers);\nconst useMergePointerEvents = (...eventsEmitters) => {\n  const onPointerCancel = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter?.onPointerCancel));\n  const onPointerDown = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter?.onPointerDown));\n  const onPointerMove = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter?.onPointerMove));\n  const onPointerUp = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter?.onPointerUp));\n  return {\n    onPointerCancel,\n    onPointerDown,\n    onPointerMove,\n    onPointerUp\n  };\n};\nconst usePointerEvents = options => {\n  const {\n    onDown,\n    onMove,\n    onUp\n  } = options;\n  const [pointerId, setPointerId] = useState();\n  const pointerDown = pointerId !== void 0;\n  const startXRef = useRef(0);\n  const startYRef = useRef(0);\n  const lastTimeStampRef = useRef(0);\n  const lastXRef = useRef(0);\n  const lastYRef = useRef(0);\n  const currTimeStampRef = useRef(0);\n  const currXRef = useRef(0);\n  const currYRef = useRef(0);\n  const onPointerDown = useCallback(event => {\n    if (!onDown(event)) {\n      return;\n    }\n    event.currentTarget.setPointerCapture(event.pointerId);\n    setPointerId(event.pointerId);\n    startXRef.current = event.clientX;\n    startYRef.current = event.clientY;\n    lastTimeStampRef.current = 0;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n  }, [onDown]);\n  const onPointerMove = useCallback(event => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    lastTimeStampRef.current = currTimeStampRef.current;\n    lastXRef.current = currXRef.current;\n    lastYRef.current = currYRef.current;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onMove({\n      diffX,\n      diffY\n    });\n  }, [onMove, pointerId]);\n  const onPointerUp = useCallback(event => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    let speedX;\n    let speedY;\n    if (lastTimeStampRef.current) {\n      const timeDiff = event.timeStamp - lastTimeStampRef.current;\n      speedX = (event.clientX - lastXRef.current) / timeDiff;\n      speedY = (event.clientY - lastYRef.current) / timeDiff;\n    } else {\n      speedX = 0;\n      speedY = 0;\n    }\n    onUp({\n      diffX,\n      diffY,\n      speedX,\n      speedY\n    });\n  }, [onUp, pointerId]);\n  const onPointerCancel = useCallback(event => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onUp({\n      diffX,\n      diffY,\n      speedX: 0,\n      speedY: 0\n    });\n  }, [onUp, pointerId]);\n  const cancelPointer = useCallback(() => {\n    setPointerId(void 0);\n  }, []);\n  return {\n    cancelPointer,\n    onPointerCancel,\n    onPointerDown,\n    onPointerMove,\n    onPointerUp,\n    pointerDown\n  };\n};\nconst getCurrSelected = options => {\n  const {\n    childrenLength,\n    diffX,\n    diffY,\n    direction,\n    onOverSwipe,\n    startSelected,\n    swipeLength\n  } = options;\n  let diff;\n  switch (direction) {\n    case \"bottom-to-top\":\n      diff = -diffY;\n      break;\n    case \"top-to-bottom\":\n      diff = diffY;\n      break;\n    case \"left-to-right\":\n      diff = diffX;\n      break;\n    case \"right-to-left\":\n      diff = -diffX;\n      break;\n  }\n  let selected = startSelected + diff / swipeLength;\n  selected = Math.max(selected, Math.ceil(startSelected) - 1);\n  selected = Math.min(selected, Math.floor(startSelected) + 1);\n  if (selected < 0) {\n    const overSwipe = Math.min(-selected, 1);\n    selected = -onOverSwipe(overSwipe);\n  } else if (selected > childrenLength - 1) {\n    const overSwipe = Math.min(selected - childrenLength + 1, 1);\n    selected = childrenLength - 1 + onOverSwipe(overSwipe);\n  }\n  return selected;\n};\nconst getNextSelected = options => {\n  const {\n    childrenLength,\n    direction,\n    speedX,\n    speedY,\n    startSelected,\n    swipeSpeed\n  } = options;\n  const selected = getCurrSelected(options);\n  let speed;\n  switch (direction) {\n    case \"bottom-to-top\":\n      speed = -speedY;\n      break;\n    case \"top-to-bottom\":\n      speed = speedY;\n      break;\n    case \"left-to-right\":\n      speed = speedX;\n      break;\n    case \"right-to-left\":\n      speed = -speedX;\n      break;\n  }\n  let newSelected;\n  if (Math.abs(speed) < swipeSpeed) {\n    newSelected = Math.round(selected);\n  } else if (speed > swipeSpeed) {\n    newSelected = Math.floor(selected) + 1;\n  } else {\n    newSelected = Math.ceil(selected) - 1;\n  }\n  newSelected = Math.max(newSelected, Math.ceil(startSelected) - 1, 0);\n  newSelected = Math.min(newSelected, Math.floor(startSelected) + 1, childrenLength - 1);\n  return newSelected;\n};\nconst defaultSwipeLength = 400;\nconst defaultOnOverSwipe = overSwipe => overSwipe / 4;\nconst defaultOnSwipeStart = event => event.isPrimary;\nconst defaultSwipeSpeed = 0.1;\nconst _FlippingPagesWithPointerControls = props => {\n  const {\n    children,\n    direction,\n    disableSwipe,\n    noSwipeClass,\n    onAnimationEnd: _onAnimationEnd,\n    onAnimationStart: _onAnimationStart,\n    onAnimationTurn: _onAnimationTurn,\n    onOverSwipe = defaultOnOverSwipe,\n    onSwipeEnd,\n    onSwipeStart = defaultOnSwipeStart,\n    onSwipeTurn,\n    swipeLength = defaultSwipeLength,\n    swipeSpeed = defaultSwipeSpeed\n  } = props;\n  const ref = useRef(null);\n  const childrenLength = Children.count(children);\n  const animationRunningRef = useRef(false);\n  const startSelectedRef = useRef(props.selected);\n  const [pointerSelected, setPointerSelected] = useState(props.selected);\n  const onAnimationStart = useCallback(() => {\n    animationRunningRef.current = true;\n    _onAnimationStart?.();\n  }, [_onAnimationStart]);\n  const onAnimationTurn = useCallback(selected2 => {\n    startSelectedRef.current = selected2;\n    _onAnimationTurn?.(selected2);\n  }, [_onAnimationTurn]);\n  const onAnimationEnd = useCallback(() => {\n    animationRunningRef.current = false;\n    _onAnimationEnd?.();\n  }, [_onAnimationEnd]);\n  const onDown = useCallback(event => {\n    if (disableSwipe) {\n      return false;\n    }\n    if (noSwipeClass) {\n      if (event.target instanceof Element) {\n        let target = event.target;\n        while (target && target !== ref.current) {\n          if (target.classList.contains(noSwipeClass)) {\n            return false;\n          }\n          target = target.parentElement;\n        }\n      }\n    }\n    if (!onSwipeStart(event)) {\n      return false;\n    }\n    if (!animationRunningRef.current) {\n      startSelectedRef.current = props.selected;\n    }\n    setPointerSelected(startSelectedRef.current);\n    return true;\n  }, [disableSwipe, noSwipeClass, onSwipeStart, props.selected]);\n  const onMove = useCallback(options => {\n    const {\n      diffX,\n      diffY\n    } = options;\n    const selected2 = getCurrSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      startSelected: startSelectedRef.current,\n      swipeLength\n    });\n    setPointerSelected(selected2);\n    onSwipeTurn?.(selected2);\n  }, [childrenLength, direction, onOverSwipe, onSwipeTurn, swipeLength]);\n  const onUp = useCallback(options => {\n    const {\n      diffX,\n      diffY,\n      speedX,\n      speedY\n    } = options;\n    const nextSelected = getNextSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      speedX,\n      speedY,\n      startSelected: startSelectedRef.current,\n      swipeLength,\n      swipeSpeed\n    });\n    onSwipeEnd?.(nextSelected);\n  }, [childrenLength, direction, onOverSwipe, onSwipeEnd, swipeLength, swipeSpeed]);\n  const {\n    cancelPointer,\n    pointerDown,\n    ..._pointerEventListeners\n  } = usePointerEvents({\n    onDown,\n    onMove,\n    onUp\n  });\n  useEffect(() => {\n    if (disableSwipe) {\n      cancelPointer();\n    }\n  }, [cancelPointer, disableSwipe]);\n  const animationDuration = pointerDown ? 0 : props.animationDuration;\n  const selected = pointerDown ? pointerSelected : props.selected;\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return pointerDown ? true : void 0;\n  }, [pointerDown, props.willChange]);\n  const pointerEventListeners = useMergePointerEvents(_pointerEventListeners, props.containerProps);\n  const containerProps = useMemo(() => ({\n    ...props.containerProps,\n    ...pointerEventListeners\n  }), [pointerEventListeners, props.containerProps]);\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [props.containerRef]);\n  return /* @__PURE__ */jsx(FlippingPagesWithAnimation, {\n    ...props,\n    animationDuration,\n    containerProps,\n    containerRef,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithPointerControls = memo(_FlippingPagesWithPointerControls);\nconst FlippingPages = FlippingPagesWithPointerControls;\nFlippingPages.displayName = \"FlippingPages\";\nexport { FlippingPages };","map":{"version":3,"names":["require$$0","memo","Children","useMemo","useRef","useCallback","useEffect","useState","mergeRefs","useResizeObserver","classNames","getTurn","selected","turn","container$1","classes$1","container","jsxRuntime","exports","reactJsxRuntime_production_min","f","k","Symbol","for","l","m","Object","prototype","hasOwnProperty","n","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","p","key","ref","__self","__source","q","c","a","g","b","d","e","h","call","defaultProps","$$typeof","type","props","_owner","current","Fragment","jsx","jsxs","defaultShadowBackground","getFlippingPagesShadow","background","_FlippingPagesShadow","willChange","className","style","opacity","Math","abs","getTransform","direction","fullPage","prevPage","nextPage","shadow","classes","_FlippingPagesCore","containerProps","containerRef","shadowBackground","children","toArray","ShadowComponent","shadowComponent","round","ceil","floor","transform","FlippingPagesCore","defaultPerspectiveMultiplier","_FlippingPagesWithPerspective","perspectiveMultiplier","height","width","refs","push","perspective","FlippingPagesWithPerspective","useAnimation","options","callback","onEnd","onStart","rafIdRef","startTimeRef","update","timestamp","requestAnimationFrame","timeElapsed","end","start","cancelAnimationFrame","stop","defaultAnimationDuration","_FlippingPagesWithAnimation","animationDuration","onAnimationEnd","onAnimationStart","onAnimationTurn","animationRunning","setAnimationRunning","startSelectedRef","setSelected","updateAnimation","maxSelectedChange","selectedChange","sign","newSelected","FlippingPagesWithAnimation","useMergeEvents","eventHandlers","event","eventHandler","useMergePointerEvents","eventsEmitters","onPointerCancel","map","eventsEmitter","onPointerDown","onPointerMove","onPointerUp","usePointerEvents","onDown","onMove","onUp","pointerId","setPointerId","pointerDown","startXRef","startYRef","lastTimeStampRef","lastXRef","lastYRef","currTimeStampRef","currXRef","currYRef","currentTarget","setPointerCapture","clientX","clientY","timeStamp","diffX","diffY","speedX","speedY","timeDiff","cancelPointer","getCurrSelected","childrenLength","onOverSwipe","startSelected","swipeLength","diff","max","min","overSwipe","getNextSelected","swipeSpeed","speed","defaultSwipeLength","defaultOnOverSwipe","defaultOnSwipeStart","isPrimary","defaultSwipeSpeed","_FlippingPagesWithPointerControls","disableSwipe","noSwipeClass","_onAnimationEnd","_onAnimationStart","_onAnimationTurn","onSwipeEnd","onSwipeStart","onSwipeTurn","count","animationRunningRef","pointerSelected","setPointerSelected","selected2","target","Element","classList","contains","parentElement","nextSelected","_pointerEventListeners","pointerEventListeners","FlippingPagesWithPointerControls","FlippingPages","displayName"],"sources":["/Users/saleem/Desktop/KClient/Web App/Ver_3.6/User Interface/website_Source files/node_modules/flipping-pages/dist/flipping-pages.es.js"],"sourcesContent":["import require$$0, { memo, Children, useMemo, useRef, useCallback, useEffect, useState } from \"react\";\nimport mergeRefs from \"react-merge-refs\";\nimport useResizeObserver from \"use-resize-observer\";\nimport classNames from \"classnames\";\nconst getTurn = (selected) => {\n  let turn = selected % 1;\n  if (turn >= 0.5) {\n    turn -= 1;\n  }\n  return turn;\n};\nconst container$1 = \"_container_1v3jh_1\";\nvar classes$1 = {\n  container: container$1\n};\nvar jsxRuntime = { exports: {} };\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f = require$$0, k = Symbol.for(\"react.element\"), l = Symbol.for(\"react.fragment\"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };\nfunction q(c, a, g) {\n  var b, d = {}, e = null, h = null;\n  g !== void 0 && (e = \"\" + g);\n  a.key !== void 0 && (e = \"\" + a.key);\n  a.ref !== void 0 && (h = a.ref);\n  for (b in a)\n    m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n  if (c && c.defaultProps)\n    for (b in a = c.defaultProps, a)\n      d[b] === void 0 && (d[b] = a[b]);\n  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };\n}\nreactJsxRuntime_production_min.Fragment = l;\nreactJsxRuntime_production_min.jsx = q;\nreactJsxRuntime_production_min.jsxs = q;\n{\n  jsxRuntime.exports = reactJsxRuntime_production_min;\n}\nconst jsx = jsxRuntime.exports.jsx;\nconst jsxs = jsxRuntime.exports.jsxs;\nconst Fragment = jsxRuntime.exports.Fragment;\nconst defaultShadowBackground = \"rgb(0, 0, 0, 0.25)\";\nconst getFlippingPagesShadow = (background = defaultShadowBackground) => {\n  const _FlippingPagesShadow = (props) => {\n    const {\n      selected,\n      willChange\n    } = props;\n    const turn = getTurn(selected);\n    return /* @__PURE__ */ jsx(\"div\", {\n      className: classes$1.container,\n      style: {\n        background,\n        opacity: Math.abs(turn) * 2,\n        willChange: willChange ? \"opacity\" : void 0\n      }\n    });\n  };\n  return memo(_FlippingPagesShadow);\n};\nconst getTransform = (direction, turn) => {\n  switch (direction) {\n    case \"bottom-to-top\":\n      return `rotateX(${turn * 180}deg)`;\n    case \"top-to-bottom\":\n      return `rotateX(${turn * -180}deg)`;\n    case \"left-to-right\":\n      return `rotateY(${turn * 180}deg)`;\n    case \"right-to-left\":\n      return `rotateY(${turn * -180}deg)`;\n  }\n};\nconst container = \"_container_1veud_1\";\nconst fullPage = \"_fullPage_1veud_7\";\nconst prevPage = \"_prevPage_1veud_8\";\nconst nextPage = \"_nextPage_1veud_9\";\nconst shadow = \"_shadow_1veud_97\";\nvar classes = {\n  container,\n  fullPage,\n  prevPage,\n  nextPage,\n  \"bottom-to-top\": \"_bottom-to-top_1veud_13\",\n  \"top-to-bottom\": \"_top-to-bottom_1veud_13\",\n  \"left-to-right\": \"_left-to-right_1veud_17\",\n  \"right-to-left\": \"_right-to-left_1veud_17\",\n  shadow\n};\nconst _FlippingPagesCore = (props) => {\n  const {\n    containerProps,\n    containerRef,\n    direction,\n    selected,\n    shadowBackground\n  } = props;\n  const children = Children.toArray(props.children);\n  const ShadowComponent = useMemo(() => props.shadowComponent ? props.shadowComponent : getFlippingPagesShadow(shadowBackground), [shadowBackground, props.shadowComponent]);\n  const turn = getTurn(selected);\n  const willChange = !!props.willChange;\n  return /* @__PURE__ */ jsxs(\"div\", {\n    ...containerProps,\n    ref: containerRef,\n    className: classNames(classes.container, containerProps?.className),\n    children: [/* @__PURE__ */ jsx(\"div\", {\n      className: classNames({\n        [classes.fullPage]: turn === 0,\n        [classes.prevPage]: turn > 0,\n        [classes.nextPage]: turn < 0\n      }, classes[direction]),\n      children: /* @__PURE__ */ jsx(\"div\", {\n        children: children[Math.round(selected)]\n      })\n    }), turn !== 0 && /* @__PURE__ */ jsxs(Fragment, {\n      children: [/* @__PURE__ */ jsx(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        children: /* @__PURE__ */ jsx(\"div\", {\n          children: children[turn > 0 ? Math.ceil(selected) : Math.floor(selected)]\n        })\n      }), /* @__PURE__ */ jsxs(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        style: {\n          transform: getTransform(direction, turn),\n          willChange: willChange ? \"transform\" : void 0\n        },\n        children: [/* @__PURE__ */ jsx(\"div\", {\n          children: children[Math.round(selected)]\n        }), /* @__PURE__ */ jsx(\"div\", {\n          className: classes.shadow,\n          children: /* @__PURE__ */ jsx(ShadowComponent, {\n            selected,\n            willChange\n          })\n        })]\n      })]\n    })]\n  });\n};\nconst FlippingPagesCore = memo(_FlippingPagesCore);\nconst defaultPerspectiveMultiplier = 2;\nconst _FlippingPagesWithPerspective = (props) => {\n  const {\n    direction,\n    perspectiveMultiplier = defaultPerspectiveMultiplier\n  } = props;\n  const {\n    ref,\n    height,\n    width\n  } = useResizeObserver();\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [ref, props.containerRef]);\n  const perspective = useMemo(() => {\n    switch (direction) {\n      case \"bottom-to-top\":\n      case \"top-to-bottom\":\n        if (!height) {\n          return;\n        }\n        return height * perspectiveMultiplier;\n      case \"left-to-right\":\n      case \"right-to-left\":\n        if (!width) {\n          return;\n        }\n        return width * perspectiveMultiplier;\n    }\n  }, [direction, perspectiveMultiplier, height, width]);\n  const containerProps = useMemo(() => ({\n    ...props.containerProps,\n    style: {\n      perspective,\n      ...props.containerProps?.style\n    }\n  }), [props.containerProps, perspective]);\n  return /* @__PURE__ */ jsx(FlippingPagesCore, {\n    ...props,\n    containerProps,\n    containerRef\n  });\n};\nconst FlippingPagesWithPerspective = memo(_FlippingPagesWithPerspective);\nconst useAnimation = (options) => {\n  const { callback, onEnd, onStart } = options;\n  const rafIdRef = useRef();\n  const startTimeRef = useRef();\n  const update = useCallback((timestamp) => {\n    if (!startTimeRef.current) {\n      startTimeRef.current = timestamp;\n      rafIdRef.current = requestAnimationFrame(update);\n      return;\n    }\n    const timeElapsed = timestamp - startTimeRef.current;\n    const end = callback(timeElapsed);\n    if (end) {\n      rafIdRef.current = void 0;\n      onEnd();\n    } else {\n      rafIdRef.current = requestAnimationFrame(update);\n    }\n  }, [callback, onEnd]);\n  const start = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n    } else {\n      onStart();\n    }\n    startTimeRef.current = void 0;\n    rafIdRef.current = requestAnimationFrame(update);\n  }, [onStart, update]);\n  const stop = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n      rafIdRef.current = void 0;\n      onEnd();\n    }\n  }, [onEnd]);\n  useEffect(() => {\n    return () => {\n      if (rafIdRef.current) {\n        cancelAnimationFrame(rafIdRef.current);\n      }\n    };\n  }, []);\n  return { start, stop };\n};\nconst defaultAnimationDuration = 400;\nconst _FlippingPagesWithAnimation = (props) => {\n  const {\n    animationDuration = defaultAnimationDuration,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn\n  } = props;\n  const [animationRunning, setAnimationRunning] = useState(false);\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return animationRunning ? true : void 0;\n  }, [props.willChange, animationRunning]);\n  const startSelectedRef = useRef(0);\n  const [selected, setSelected] = useState(props.selected);\n  const onStart = useCallback(() => {\n    setAnimationRunning(true);\n    onAnimationStart?.();\n  }, [onAnimationStart]);\n  const onEnd = useCallback(() => {\n    setAnimationRunning(false);\n    onAnimationEnd?.();\n  }, [onAnimationEnd]);\n  const updateAnimation = useCallback((timeElapsed) => {\n    const maxSelectedChange = props.selected - startSelectedRef.current;\n    const selectedChange = Math.sign(maxSelectedChange) * timeElapsed / animationDuration;\n    if (Math.abs(selectedChange) >= Math.abs(maxSelectedChange)) {\n      setSelected(props.selected);\n      return true;\n    }\n    const newSelected = startSelectedRef.current + selectedChange;\n    setSelected(newSelected);\n    onAnimationTurn?.(newSelected);\n    return false;\n  }, [animationDuration, onAnimationTurn, props.selected]);\n  const {\n    start,\n    stop\n  } = useAnimation({\n    callback: updateAnimation,\n    onEnd,\n    onStart\n  });\n  useEffect(() => {\n    if (selected === props.selected) {\n      stop();\n      return;\n    }\n    if (!animationDuration) {\n      stop();\n      setSelected(props.selected);\n      return;\n    }\n    startSelectedRef.current = selected;\n    start();\n  }, [animationDuration, props.selected]);\n  return /* @__PURE__ */ jsx(FlippingPagesWithPerspective, {\n    ...props,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithAnimation = memo(_FlippingPagesWithAnimation);\nconst useMergeEvents = (...eventHandlers) => useCallback((event) => {\n  for (const eventHandler of eventHandlers) {\n    eventHandler?.(event);\n  }\n}, eventHandlers);\nconst useMergePointerEvents = (...eventsEmitters) => {\n  const onPointerCancel = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerCancel));\n  const onPointerDown = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerDown));\n  const onPointerMove = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerMove));\n  const onPointerUp = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerUp));\n  return { onPointerCancel, onPointerDown, onPointerMove, onPointerUp };\n};\nconst usePointerEvents = (options) => {\n  const { onDown, onMove, onUp } = options;\n  const [pointerId, setPointerId] = useState();\n  const pointerDown = pointerId !== void 0;\n  const startXRef = useRef(0);\n  const startYRef = useRef(0);\n  const lastTimeStampRef = useRef(0);\n  const lastXRef = useRef(0);\n  const lastYRef = useRef(0);\n  const currTimeStampRef = useRef(0);\n  const currXRef = useRef(0);\n  const currYRef = useRef(0);\n  const onPointerDown = useCallback((event) => {\n    if (!onDown(event)) {\n      return;\n    }\n    event.currentTarget.setPointerCapture(event.pointerId);\n    setPointerId(event.pointerId);\n    startXRef.current = event.clientX;\n    startYRef.current = event.clientY;\n    lastTimeStampRef.current = 0;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n  }, [onDown]);\n  const onPointerMove = useCallback((event) => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    lastTimeStampRef.current = currTimeStampRef.current;\n    lastXRef.current = currXRef.current;\n    lastYRef.current = currYRef.current;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onMove({ diffX, diffY });\n  }, [onMove, pointerId]);\n  const onPointerUp = useCallback((event) => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    let speedX;\n    let speedY;\n    if (lastTimeStampRef.current) {\n      const timeDiff = event.timeStamp - lastTimeStampRef.current;\n      speedX = (event.clientX - lastXRef.current) / timeDiff;\n      speedY = (event.clientY - lastYRef.current) / timeDiff;\n    } else {\n      speedX = 0;\n      speedY = 0;\n    }\n    onUp({ diffX, diffY, speedX, speedY });\n  }, [onUp, pointerId]);\n  const onPointerCancel = useCallback((event) => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onUp({ diffX, diffY, speedX: 0, speedY: 0 });\n  }, [onUp, pointerId]);\n  const cancelPointer = useCallback(() => {\n    setPointerId(void 0);\n  }, []);\n  return {\n    cancelPointer,\n    onPointerCancel,\n    onPointerDown,\n    onPointerMove,\n    onPointerUp,\n    pointerDown\n  };\n};\nconst getCurrSelected = (options) => {\n  const { childrenLength, diffX, diffY, direction, onOverSwipe, startSelected, swipeLength } = options;\n  let diff;\n  switch (direction) {\n    case \"bottom-to-top\":\n      diff = -diffY;\n      break;\n    case \"top-to-bottom\":\n      diff = diffY;\n      break;\n    case \"left-to-right\":\n      diff = diffX;\n      break;\n    case \"right-to-left\":\n      diff = -diffX;\n      break;\n  }\n  let selected = startSelected + diff / swipeLength;\n  selected = Math.max(selected, Math.ceil(startSelected) - 1);\n  selected = Math.min(selected, Math.floor(startSelected) + 1);\n  if (selected < 0) {\n    const overSwipe = Math.min(-selected, 1);\n    selected = -onOverSwipe(overSwipe);\n  } else if (selected > childrenLength - 1) {\n    const overSwipe = Math.min(selected - childrenLength + 1, 1);\n    selected = childrenLength - 1 + onOverSwipe(overSwipe);\n  }\n  return selected;\n};\nconst getNextSelected = (options) => {\n  const { childrenLength, direction, speedX, speedY, startSelected, swipeSpeed } = options;\n  const selected = getCurrSelected(options);\n  let speed;\n  switch (direction) {\n    case \"bottom-to-top\":\n      speed = -speedY;\n      break;\n    case \"top-to-bottom\":\n      speed = speedY;\n      break;\n    case \"left-to-right\":\n      speed = speedX;\n      break;\n    case \"right-to-left\":\n      speed = -speedX;\n      break;\n  }\n  let newSelected;\n  if (Math.abs(speed) < swipeSpeed) {\n    newSelected = Math.round(selected);\n  } else if (speed > swipeSpeed) {\n    newSelected = Math.floor(selected) + 1;\n  } else {\n    newSelected = Math.ceil(selected) - 1;\n  }\n  newSelected = Math.max(newSelected, Math.ceil(startSelected) - 1, 0);\n  newSelected = Math.min(newSelected, Math.floor(startSelected) + 1, childrenLength - 1);\n  return newSelected;\n};\nconst defaultSwipeLength = 400;\nconst defaultOnOverSwipe = (overSwipe) => overSwipe / 4;\nconst defaultOnSwipeStart = (event) => event.isPrimary;\nconst defaultSwipeSpeed = 0.1;\nconst _FlippingPagesWithPointerControls = (props) => {\n  const {\n    children,\n    direction,\n    disableSwipe,\n    noSwipeClass,\n    onAnimationEnd: _onAnimationEnd,\n    onAnimationStart: _onAnimationStart,\n    onAnimationTurn: _onAnimationTurn,\n    onOverSwipe = defaultOnOverSwipe,\n    onSwipeEnd,\n    onSwipeStart = defaultOnSwipeStart,\n    onSwipeTurn,\n    swipeLength = defaultSwipeLength,\n    swipeSpeed = defaultSwipeSpeed\n  } = props;\n  const ref = useRef(null);\n  const childrenLength = Children.count(children);\n  const animationRunningRef = useRef(false);\n  const startSelectedRef = useRef(props.selected);\n  const [pointerSelected, setPointerSelected] = useState(props.selected);\n  const onAnimationStart = useCallback(() => {\n    animationRunningRef.current = true;\n    _onAnimationStart?.();\n  }, [_onAnimationStart]);\n  const onAnimationTurn = useCallback((selected2) => {\n    startSelectedRef.current = selected2;\n    _onAnimationTurn?.(selected2);\n  }, [_onAnimationTurn]);\n  const onAnimationEnd = useCallback(() => {\n    animationRunningRef.current = false;\n    _onAnimationEnd?.();\n  }, [_onAnimationEnd]);\n  const onDown = useCallback((event) => {\n    if (disableSwipe) {\n      return false;\n    }\n    if (noSwipeClass) {\n      if (event.target instanceof Element) {\n        let target = event.target;\n        while (target && target !== ref.current) {\n          if (target.classList.contains(noSwipeClass)) {\n            return false;\n          }\n          target = target.parentElement;\n        }\n      }\n    }\n    if (!onSwipeStart(event)) {\n      return false;\n    }\n    if (!animationRunningRef.current) {\n      startSelectedRef.current = props.selected;\n    }\n    setPointerSelected(startSelectedRef.current);\n    return true;\n  }, [disableSwipe, noSwipeClass, onSwipeStart, props.selected]);\n  const onMove = useCallback((options) => {\n    const {\n      diffX,\n      diffY\n    } = options;\n    const selected2 = getCurrSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      startSelected: startSelectedRef.current,\n      swipeLength\n    });\n    setPointerSelected(selected2);\n    onSwipeTurn?.(selected2);\n  }, [childrenLength, direction, onOverSwipe, onSwipeTurn, swipeLength]);\n  const onUp = useCallback((options) => {\n    const {\n      diffX,\n      diffY,\n      speedX,\n      speedY\n    } = options;\n    const nextSelected = getNextSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      speedX,\n      speedY,\n      startSelected: startSelectedRef.current,\n      swipeLength,\n      swipeSpeed\n    });\n    onSwipeEnd?.(nextSelected);\n  }, [childrenLength, direction, onOverSwipe, onSwipeEnd, swipeLength, swipeSpeed]);\n  const {\n    cancelPointer,\n    pointerDown,\n    ..._pointerEventListeners\n  } = usePointerEvents({\n    onDown,\n    onMove,\n    onUp\n  });\n  useEffect(() => {\n    if (disableSwipe) {\n      cancelPointer();\n    }\n  }, [cancelPointer, disableSwipe]);\n  const animationDuration = pointerDown ? 0 : props.animationDuration;\n  const selected = pointerDown ? pointerSelected : props.selected;\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return pointerDown ? true : void 0;\n  }, [pointerDown, props.willChange]);\n  const pointerEventListeners = useMergePointerEvents(_pointerEventListeners, props.containerProps);\n  const containerProps = useMemo(() => ({\n    ...props.containerProps,\n    ...pointerEventListeners\n  }), [pointerEventListeners, props.containerProps]);\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [props.containerRef]);\n  return /* @__PURE__ */ jsx(FlippingPagesWithAnimation, {\n    ...props,\n    animationDuration,\n    containerProps,\n    containerRef,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithPointerControls = memo(_FlippingPagesWithPointerControls);\nconst FlippingPages = FlippingPagesWithPointerControls;\nFlippingPages.displayName = \"FlippingPages\";\nexport { FlippingPages };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}