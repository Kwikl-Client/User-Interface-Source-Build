{"ast":null,"code":"import { _PdfStream } from './base-stream';\nimport { _PdfDictionary, _PdfReferenceSet, _isCommand, _PdfReference, _PdfName } from './pdf-primitives';\nimport { BaseException, FormatError, _escapePdfName, _bytesToString, ParserEndOfFileException, _numberToString, _stringToPdfString } from './utils';\nimport { _PdfParser, _PdfLexicalOperator } from './pdf-parser';\nimport { _PdfBaseStream } from './base-stream';\nimport { PdfCrossReferenceType } from './enumerator';\nimport { _MD5, _PdfEncryptor } from './security/encryptor';\nimport { CompressedStreamWriter } from '@syncfusion/ej2-compression';\nvar _PdfCrossReference = /** @class */function () {\n  function _PdfCrossReference(document, password) {\n    this._version = '';\n    this._newLine = '\\r\\n';\n    this._password = password;\n    this._document = document;\n    this._stream = document._stream;\n    this._entries = [];\n    this._crossReferencePosition = Object.create(null);\n    this._cacheMap = new Map(); // eslint-disable-line\n    this._pendingRefs = new _PdfReferenceSet();\n  }\n  _PdfCrossReference.prototype._setStartXRef = function (startXRef) {\n    this._startXRefQueue = [startXRef];\n    this._prevStartXref = startXRef;\n  };\n  _PdfCrossReference.prototype._parse = function (recoveryMode) {\n    var trailerDictionary;\n    if (!recoveryMode) {\n      trailerDictionary = this._readXRef();\n    } else {\n      trailerDictionary = this._indexObjects();\n    }\n    trailerDictionary.assignXref(this);\n    this._nextReferenceNumber = trailerDictionary.get('Size');\n    this._trailer = trailerDictionary;\n    var encrypt = trailerDictionary.get('Encrypt');\n    if (encrypt) {\n      this._document._isEncrypted = true;\n      this._ids = trailerDictionary.get('ID');\n      this._permissionFlags = encrypt.get('P');\n      var fileId = this._ids && this._ids.length ? this._ids[0] : '';\n      encrypt.suppressEncryption = true;\n      this._encrypt = new _PdfEncryptor(encrypt, fileId, this._password);\n      this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.stream;\n      this._document._isUserPassword = this._encrypt._isUserPassword;\n      this._document._encryptOnlyAttachment = this._encrypt._encryptOnlyAttachment;\n      if (this._encrypt._encryptOnlyAttachment) {\n        this._document._hasUserPasswordOnly = true;\n        this._document._encryptMetaData = false;\n      } else {\n        this._document._hasUserPasswordOnly = this._encrypt._hasUserPasswordOnly;\n        this._document._encryptMetaData = encrypt.has('EncryptMetadata') ? encrypt.get('EncryptMetadata') : true;\n      }\n    }\n    var hasRoot = false;\n    try {\n      var root = trailerDictionary.get('Root');\n      if (root) {\n        var pagesEntry = root.get('Pages');\n        if (pagesEntry) {\n          this._root = root;\n          hasRoot = true;\n        }\n      }\n    } catch (ex) {\n      throw new BaseException('Invalid cross reference', 'InvalidXRef');\n    }\n    if (!hasRoot) {\n      if (!recoveryMode) {\n        throw new BaseException('Invalid cross reference', 'XRefParseException');\n      } else {\n        throw new BaseException('Invalid cross reference', 'InvalidXRef');\n      }\n    }\n  };\n  _PdfCrossReference.prototype._getEntry = function (i) {\n    var xrefEntry = this._entries[i]; // eslint-disable-line\n    if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {\n      return xrefEntry;\n    }\n    return null;\n  };\n  _PdfCrossReference.prototype._fetch = function (ref, suppressEncryption) {\n    var entry; // eslint-disable-line\n    if (!(ref instanceof _PdfReference)) {\n      throw new Error('ref object is not a reference');\n    }\n    var objectNumber = ref.objectNumber;\n    var cacheEntry = this._cacheMap.get(ref); // eslint-disable-line\n    if (typeof cacheEntry !== 'undefined') {\n      if (cacheEntry instanceof _PdfDictionary && !cacheEntry.objId) {\n        cacheEntry.objId = objectNumber;\n      }\n      return cacheEntry;\n    }\n    var xrefEntry = this._getEntry(objectNumber);\n    if (xrefEntry === null) {\n      this._cacheMap.set(ref, xrefEntry);\n      return xrefEntry;\n    }\n    if (this._pendingRefs.has(ref)) {\n      this._pendingRefs.remove(ref);\n      throw new Error('circular reference');\n    }\n    this._pendingRefs.put(ref);\n    try {\n      if (xrefEntry.uncompressed) {\n        entry = this._fetchUncompressed(ref, xrefEntry, suppressEncryption);\n      } else {\n        entry = this._fetchCompressed(ref, xrefEntry);\n      }\n      this._pendingRefs.remove(ref);\n    } catch (ex) {\n      this._pendingRefs.remove(ref);\n      throw ex;\n    }\n    return entry;\n  };\n  _PdfCrossReference.prototype._fetchUncompressed = function (reference, xrefEntry, suppressEncryption) {\n    var generationNumber = reference.generationNumber;\n    var objectNumber = reference.objectNumber;\n    if (xrefEntry.gen !== generationNumber) {\n      throw new BaseException(\"Inconsistent generation in XRef: \" + reference, 'XRefEntryException');\n    }\n    var stream = this._stream.makeSubStream(xrefEntry.offset + this._stream.start, undefined);\n    var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);\n    var obj1 = parser.getObject();\n    var obj2 = parser.getObject();\n    var obj3 = parser.getObject();\n    if (obj1 !== objectNumber || obj2 !== generationNumber || typeof obj3 === 'undefined') {\n      throw new BaseException(\"Bad (uncompressed) XRef entry: \" + reference, 'XRefEntryException');\n    }\n    var entry; // eslint-disable-line\n    if (this._encrypt && !suppressEncryption) {\n      entry = parser.getObject(this._encrypt._createCipherTransform(reference.objectNumber, reference.generationNumber));\n    } else {\n      entry = parser.getObject();\n    }\n    if (!(entry instanceof _PdfBaseStream)) {\n      this._cacheMap.set(reference, entry);\n    }\n    if (entry instanceof _PdfDictionary) {\n      entry.objId = reference.toString();\n    } else if (entry instanceof _PdfBaseStream) {\n      entry.dictionary.objId = reference.toString();\n    }\n    return entry;\n  };\n  _PdfCrossReference.prototype._fetchCompressed = function (ref, xrefEntry) {\n    var tableOffset = xrefEntry.offset;\n    var stream = this._fetch(_PdfReference.get(tableOffset, 0));\n    if (typeof stream === 'undefined') {\n      throw new FormatError('bad ObjStm stream');\n    }\n    var first = stream.dictionary.get('First');\n    var n = stream.dictionary.get('N');\n    var gen = ref.generationNumber;\n    if (!Number.isInteger(first) || !Number.isInteger(n)) {\n      throw new FormatError('invalid first and n parameters for ObjStm stream');\n    }\n    var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);\n    var nums = new Array(n);\n    var offsets = new Array(n);\n    for (var i = 0; i < n; ++i) {\n      var value = parser.getObject();\n      if (!Number.isInteger(value)) {\n        throw new FormatError(\"invalid object number in the ObjStm stream: \" + value);\n      }\n      var offset = parser.getObject();\n      if (!Number.isInteger(offset)) {\n        throw new FormatError(\"invalid object offset in the ObjStm stream: \" + offset);\n      }\n      nums[i] = value; // eslint-disable-line\n      offsets[i] = offset; // eslint-disable-line\n    }\n    var start = (stream.start || 0) + first;\n    var entries = new Array(n); // eslint-disable-line\n    for (var i = 0; i < n; ++i) {\n      var length_1 = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined; // eslint-disable-line\n      if (length_1 < 0) {\n        throw new FormatError('Invalid offset in the ObjStm stream.');\n      }\n      parser = new _PdfParser(new _PdfLexicalOperator(stream.makeSubStream(start + offsets[i], length_1, stream.dictionary)), this, true); // eslint-disable-line\n      var obj = parser.getObject(); // eslint-disable-line\n      entries[i] = obj; // eslint-disable-line\n      if (obj instanceof _PdfBaseStream) {\n        continue;\n      }\n      var value = nums[i]; // eslint-disable-line\n      var entry = this._entries[value]; // eslint-disable-line\n      if (entry && entry.offset === tableOffset && entry.gen === i) {\n        var objId = value + \" \" + gen;\n        this._cacheMap.set(_PdfReference.get(value, gen), obj);\n        if (obj instanceof _PdfDictionary) {\n          obj.objId = objId;\n        }\n      }\n    }\n    var result = entries[xrefEntry.gen]; // eslint-disable-line\n    if (typeof result === 'undefined') {\n      throw new BaseException(\"Bad (compressed) XRef entry: \" + ref, 'XRefEntryException');\n    }\n    return result;\n  };\n  _PdfCrossReference.prototype._readXRef = function (recoveryMode) {\n    if (recoveryMode === void 0) {\n      recoveryMode = false;\n    }\n    var stream = this._stream;\n    var startXRefParsedCache = new Set();\n    try {\n      while (this._startXRefQueue.length) {\n        var startXRef = this._startXRefQueue[0];\n        if (this._prevStartXref < startXRef) {\n          this._prevStartXref = startXRef;\n        }\n        if (startXRefParsedCache.has(startXRef)) {\n          this._startXRefQueue.shift();\n          continue;\n        }\n        startXRefParsedCache.add(startXRef);\n        stream.position = startXRef + stream.start;\n        var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);\n        var obj = parser.getObject(); // eslint-disable-line\n        var dictionary = void 0;\n        if (_isCommand(obj, 'xref')) {\n          if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {\n            this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.table;\n          }\n          dictionary = this._processXRefTable(parser);\n          if (!this._topDictionary) {\n            this._topDictionary = dictionary;\n          }\n          obj = dictionary.get('XRefStm');\n          if (Number.isInteger(obj)) {\n            var position = obj; // eslint-disable-line\n            if (!(position in this._crossReferencePosition)) {\n              this._crossReferencePosition[position] = 1; // eslint-disable-line\n              this._startXRefQueue.push(position);\n            }\n          }\n        } else if (Number.isInteger(obj)) {\n          if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {\n            this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.stream;\n          }\n          var gen = parser.getObject();\n          var command = parser.getObject();\n          obj = parser.getObject();\n          if (typeof gen === 'undefined' || !Number.isInteger(gen) || !_isCommand(command, 'obj') || !(obj instanceof _PdfBaseStream)) {\n            throw new FormatError('Invalid cross reference stream');\n          }\n          dictionary = this._processXRefStream(obj);\n          if (!this._topDictionary) {\n            this._topDictionary = dictionary;\n          }\n          if (!dictionary) {\n            throw new FormatError('Failed to read XRef stream');\n          }\n        } else {\n          throw new FormatError('Invalid XRef stream header');\n        }\n        obj = dictionary.get('Prev');\n        if (Number.isInteger(obj)) {\n          this._startXRefQueue.push(obj);\n        } else if (obj instanceof _PdfReference) {\n          this._startXRefQueue.push(obj.objectNumber);\n        }\n        this._startXRefQueue.shift();\n      }\n      return this._topDictionary;\n    } catch (e) {\n      this._startXRefQueue.shift();\n    }\n    if (recoveryMode) {\n      return undefined;\n    }\n    throw new BaseException('Invalid cross reference', 'XRefParseException');\n  };\n  _PdfCrossReference.prototype._readToken = function (data, offset) {\n    var lf = 0xa;\n    var cr = 0xd;\n    var lt = 0x3c;\n    var token = '';\n    var ch = data[offset]; // eslint-disable-line\n    while (ch !== lf && ch !== cr && ch !== lt) {\n      if (++offset >= data.length) {\n        break;\n      }\n      token += String.fromCharCode(ch);\n      ch = data[offset]; // eslint-disable-line\n    }\n    return token;\n  };\n  _PdfCrossReference.prototype._skipUntil = function (data, offset, what) {\n    var length = what.length;\n    var dataLength = data.length;\n    var skipped = 0;\n    while (offset < dataLength) {\n      var i = 0;\n      while (i < length && data[offset + i] === what[i]) {\n        // eslint-disable-line\n        ++i;\n      }\n      if (i >= length) {\n        break;\n      }\n      offset++;\n      skipped++;\n    }\n    return skipped;\n  };\n  _PdfCrossReference.prototype._indexObjects = function () {\n    var tab = 0x9;\n    var lf = 0xa;\n    var cr = 0xd;\n    var space = 0x20;\n    var percent = 0x25;\n    var objRegExp = /^(\\d+)\\s+(\\d+)\\s+obj\\b/;\n    var endobjRegExp = /\\bendobj[\\b\\s]$/;\n    var nestedObjRegExp = /\\s+(\\d+\\s+\\d+\\s+obj[\\b\\s<])$/;\n    var checkContentLength = 25;\n    var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);\n    var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);\n    var objBytes = new Uint8Array([111, 98, 106]);\n    var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);\n    this._entries.length = 0;\n    this._cacheMap.clear();\n    var stream = this._stream;\n    stream.position = 0;\n    var buffer = stream.getBytes();\n    var length = buffer.length;\n    var position = stream.start;\n    var trailers = [];\n    var crossReferencePosition = [];\n    while (position < length) {\n      var ch = buffer[position]; // eslint-disable-line\n      if (ch === tab || ch === lf || ch === cr || ch === space) {\n        ++position;\n        continue;\n      }\n      if (ch === percent) {\n        do {\n          ++position;\n          if (position >= length) {\n            break;\n          }\n          ch = buffer[position]; // eslint-disable-line\n        } while (ch !== lf && ch !== cr);\n        continue;\n      }\n      var token = this._readToken(buffer, position);\n      var m = void 0; // eslint-disable-line\n      if (token.startsWith('xref') && (token.length === 4 || /\\s/.test(token[4]))) {\n        position += this._skipUntil(buffer, position, trailerBytes);\n        trailers.push(position);\n        position += this._skipUntil(buffer, position, startxrefBytes);\n      } else {\n        m = objRegExp.exec(token);\n        if (m) {\n          var objectNumber = Number.parseInt(m[1]) | 0; // eslint-disable-line\n          var gen = Number.parseInt(m[2]) | 0; // eslint-disable-line\n          var contentLength = void 0;\n          var startPos = position + token.length;\n          var updateEntries = false;\n          if (!this._entries[objectNumber]) {\n            // eslint-disable-line\n            updateEntries = true;\n          } else if (this._entries[objectNumber].gen === gen) {\n            // eslint-disable-line\n            try {\n              var subStream = stream.makeSubStream(startPos, stream.length - startPos);\n              var lexicalOperator = new _PdfLexicalOperator(subStream);\n              var parser = new _PdfParser(lexicalOperator, null);\n              parser.getObject();\n              updateEntries = true;\n            } catch (ex) {\n              updateEntries = !(ex instanceof ParserEndOfFileException);\n            }\n          }\n          if (updateEntries) {\n            var info = new _PdfObjectInformation();\n            info.offset = position - stream.start;\n            info.gen = gen;\n            info.uncompressed = true;\n            this._entries[objectNumber] = info; // eslint-disable-line\n          }\n          while (startPos < buffer.length) {\n            var endPos = startPos + this._skipUntil(buffer, startPos, objBytes) + 4;\n            contentLength = endPos - position;\n            var checkPos = Math.max(endPos - checkContentLength, startPos);\n            var tokenStr = _bytesToString(buffer.subarray(checkPos, endPos));\n            if (endobjRegExp.test(tokenStr)) {\n              break;\n            } else {\n              var objToken = nestedObjRegExp.exec(tokenStr); // eslint-disable-line\n              if (objToken && objToken[1]) {\n                contentLength -= objToken[1].length;\n                break;\n              }\n            }\n            startPos = endPos;\n          }\n          var content = buffer.subarray(position, position + contentLength);\n          var xrefTagOffset = this._skipUntil(content, 0, xrefBytes);\n          if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {\n            crossReferencePosition.push(position - stream.start);\n            this._crossReferencePosition[position - stream.start] = 1;\n          }\n          position += contentLength;\n        } else if (token.startsWith('trailer') && (token.length === 7 || /\\s/.test(token[7]))) {\n          trailers.push(position);\n          position += this._skipUntil(buffer, position, startxrefBytes);\n        } else {\n          position += token.length + 1;\n        }\n      }\n    }\n    for (var i = 0; i < crossReferencePosition.length; ++i) {\n      this._startXRefQueue.push(crossReferencePosition[i]); // eslint-disable-line\n      this._readXRef(true);\n    }\n    var trailerDict;\n    for (var i = 0; i < trailers.length; ++i) {\n      stream.position = trailers[i]; // eslint-disable-line\n      var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true, true);\n      var obj = parser.getObject(); // eslint-disable-line\n      if (!_isCommand(obj, 'trailer')) {\n        continue;\n      }\n      var dictionary = parser.getObject(); // eslint-disable-line\n      if (!(dictionary instanceof _PdfDictionary)) {\n        continue;\n      }\n      try {\n        var rootDict = dictionary.get('Root'); // eslint-disable-line\n        if (!(rootDict instanceof _PdfDictionary)) {\n          continue;\n        }\n        var pagesDict = rootDict.get('Pages'); // eslint-disable-line\n        if (!(pagesDict instanceof _PdfDictionary)) {\n          continue;\n        }\n        var pagesCount = pagesDict.get('Count');\n        if (typeof pagesCount === 'undefined' || !Number.isInteger(pagesCount)) {\n          continue;\n        }\n      } catch (ex) {\n        continue;\n      }\n      if (dictionary.has('ID')) {\n        return dictionary;\n      }\n      trailerDict = dictionary;\n    }\n    if (trailerDict) {\n      return trailerDict;\n    }\n    if (this._topDictionary) {\n      return this._topDictionary;\n    }\n    throw new BaseException('Invalid PDF structure.', 'InvalidPDFException');\n  };\n  _PdfCrossReference.prototype._processXRefTable = function (parser) {\n    if (typeof this._tableState === 'undefined') {\n      var tableState = new _PdfCrossTableState();\n      tableState.entryNum = 0;\n      tableState.streamPos = parser.lexicalOperator.stream.position;\n      tableState.parserBuf1 = parser.first;\n      tableState.parserBuf2 = parser.second;\n      this._tableState = tableState;\n    }\n    var obj = this._readXRefTable(parser);\n    if (!_isCommand(obj, 'trailer')) {\n      throw new FormatError('Invalid XRef table: could not find trailer dictionary');\n    }\n    var topDictionary = parser.getObject(); // eslint-disable-line\n    var dictionary;\n    if (topDictionary) {\n      if (topDictionary instanceof _PdfDictionary) {\n        dictionary = topDictionary;\n      } else if (topDictionary instanceof _PdfBaseStream && topDictionary.dictionary) {\n        dictionary = topDictionary.dictionary;\n      }\n    }\n    if (!dictionary) {\n      throw new FormatError('Invalid cross reference: could not parse trailer dictionary');\n    }\n    this._tableState = undefined;\n    return dictionary;\n  };\n  _PdfCrossReference.prototype._readXRefTable = function (parser) {\n    var stream = parser.lexicalOperator.stream;\n    stream.position = this._tableState.streamPos;\n    parser.first = this._tableState.parserBuf1;\n    parser.second = this._tableState.parserBuf2;\n    var obj; // eslint-disable-line\n    while (true) {\n      // eslint-disable-line\n      if (typeof this._tableState.firstEntryNum === 'undefined' || typeof this._tableState.entryCount === 'undefined') {\n        obj = parser.getObject();\n        if (_isCommand(obj, 'trailer')) {\n          break;\n        }\n        this._tableState.firstEntryNum = obj;\n        this._tableState.entryCount = parser.getObject();\n      }\n      var first = this._tableState.firstEntryNum;\n      var count = this._tableState.entryCount;\n      if (!Number.isInteger(first) || !Number.isInteger(count)) {\n        throw new FormatError('Invalid cross reference: wrong types in subsection header');\n      }\n      for (var i = this._tableState.entryNum; i < count; i++) {\n        this._tableState.streamPos = stream.position;\n        this._tableState.entryNum = i;\n        this._tableState.parserBuf1 = parser.first;\n        this._tableState.parserBuf2 = parser.second;\n        var entry = new _PdfObjectInformation();\n        entry.offset = parser.getObject();\n        entry.gen = parser.getObject();\n        var type = parser.getObject();\n        if (type) {\n          switch (type.command) {\n            case 'f':\n              entry.free = true;\n              break;\n            case 'n':\n              entry.uncompressed = true;\n              break;\n          }\n        }\n        if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {\n          throw new FormatError(\"Invalid entry in cross reference subsection: \" + first + \", \" + count);\n        }\n        if (i === 0 && entry.free && first === 1) {\n          first = 0;\n        }\n        if (!this._entries[i + first]) {\n          this._entries[i + first] = entry;\n        }\n      }\n      this._tableState.entryNum = 0;\n      this._tableState.streamPos = stream.position;\n      this._tableState.parserBuf1 = parser.first;\n      this._tableState.parserBuf2 = parser.second;\n      this._tableState.firstEntryNum = undefined;\n      this._tableState.entryCount = undefined;\n    }\n    if (this._entries[0] && !this._entries[0].free) {\n      throw new FormatError('Invalid XRef table: unexpected first object');\n    }\n    return obj;\n  };\n  _PdfCrossReference.prototype._processXRefStream = function (stream) {\n    if (typeof this._streamState === 'undefined') {\n      var streamParameters = stream.dictionary;\n      var streamState = new _PdfStreamState();\n      var index = streamParameters.getArray('Index');\n      if (!index) {\n        index = [0, streamParameters.get('Size')];\n      }\n      streamState.entryRanges = index;\n      streamState.byteWidths = streamParameters.getArray('W');\n      streamState.entryNum = 0;\n      streamState.streamPos = stream.position;\n      this._streamState = streamState;\n    }\n    this._readXRefStream(stream);\n    this._streamState = undefined;\n    return stream.dictionary;\n  };\n  _PdfCrossReference.prototype._readXRefStream = function (stream) {\n    stream.position = this._streamState.streamPos;\n    var typeFieldWidth = this._streamState.byteWidths[0];\n    var offsetFieldWidth = this._streamState.byteWidths[1];\n    var generationFieldWidth = this._streamState.byteWidths[2];\n    var entryRanges = this._streamState.entryRanges;\n    while (entryRanges.length > 0) {\n      var first = entryRanges[0];\n      var n = entryRanges[1];\n      if (!Number.isInteger(first) || !Number.isInteger(n)) {\n        throw new FormatError(\"Invalid XRef range fields: \" + first + \", \" + n);\n      }\n      if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {\n        throw new FormatError(\"Invalid XRef entry fields length: \" + first + \", \" + n);\n      }\n      for (var i = this._streamState.entryNum; i < n; ++i) {\n        this._streamState.entryNum = i;\n        this._streamState.streamPos = stream.position;\n        var type = 0;\n        var offset = 0;\n        var generation = 0;\n        for (var j = 0; j < typeFieldWidth; ++j) {\n          var typeByte = stream.getByte();\n          if (typeByte === -1) {\n            throw new FormatError('invalid cross reference byte width type.');\n          }\n          type = type << 8 | typeByte;\n        }\n        if (typeFieldWidth === 0) {\n          type = 1;\n        }\n        for (var j = 0; j < offsetFieldWidth; ++j) {\n          var offsetByte = stream.getByte();\n          if (offsetByte === -1) {\n            throw new FormatError('invalid cross reference byte width offset.');\n          }\n          offset = offset << 8 | offsetByte;\n        }\n        for (var j = 0; j < generationFieldWidth; ++j) {\n          var generationByte = stream.getByte();\n          if (generationByte === -1) {\n            throw new FormatError('invalid cross reference byte width generation.');\n          }\n          generation = generation << 8 | generationByte;\n        }\n        var entry = new _PdfObjectInformation();\n        entry.offset = offset;\n        entry.gen = generation;\n        switch (type) {\n          case 0:\n            entry.free = true;\n            break;\n          case 1:\n            entry.uncompressed = true;\n            break;\n          case 2:\n            break;\n          default:\n            throw new FormatError(\"Invalid XRef entry type: \" + type);\n        }\n        if (!this._entries[first + i]) {\n          this._entries[first + i] = entry;\n        }\n      }\n      this._streamState.entryNum = 0;\n      this._streamState.streamPos = stream.position;\n      entryRanges.splice(0, 2);\n    }\n  };\n  _PdfCrossReference.prototype._getCatalogObj = function () {\n    return this._root;\n  };\n  _PdfCrossReference.prototype._save = function () {\n    var _this = this;\n    var currentLength = this._stream.length;\n    var buffer = [this._newLine.charCodeAt(0), this._newLine.charCodeAt(1), 37, 80, 68, 70, 45];\n    this._writeString(\"\" + this._version + this._newLine, buffer);\n    buffer.push(0x25, 0x83, 0x92, 0xfa, 0xfe);\n    this._writeString(this._newLine, buffer);\n    var updatedCount = 0;\n    var uncompressedCount = 0;\n    if (this._document._fileStructure._crossReferenceType === PdfCrossReferenceType.stream) {\n      var data = [];\n      var updatedStream_1 = [];\n      var archiveXRef_1 = '';\n      var indexes_1 = [];\n      indexes_1.push(0, 1);\n      var collection_1 = [];\n      var uncompressedOffsets_1 = [];\n      this._cacheMap.forEach(function (value, key) {\n        var dictionary;\n        if (value instanceof _PdfBaseStream) {\n          dictionary = value.dictionary;\n        }\n        if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n          indexes_1.push(key.objectNumber, 1);\n          uncompressedOffsets_1.push(currentLength + buffer.length);\n          var cipher_1;\n          if (_this._encrypt) {\n            cipher_1 = _this._encrypt._createCipherTransform(key.objectNumber, key.generationNumber);\n          }\n          _this._writeObject(value, buffer, key, cipher_1);\n          uncompressedCount++;\n          dictionary._updated = false;\n        }\n      });\n      this._cacheMap.forEach(function (value, key) {\n        if (value instanceof _PdfDictionary) {\n          if (value._updated && (!value.isCatalog || _this._allowCatalog)) {\n            archiveXRef_1 += key.objectNumber + \" \" + updatedStream_1.length + _this._newLine;\n            collection_1.push(key.objectNumber, 1);\n            updatedCount++;\n            _this._writeObject(value, updatedStream_1);\n          }\n        } else if (value instanceof _PdfBaseStream) {\n          var dictionary = value.dictionary;\n          if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n            indexes_1.push(key.objectNumber, 1);\n            uncompressedOffsets_1.push(currentLength + buffer.length);\n            _this._writeObject(value, buffer, key);\n            uncompressedCount++;\n            dictionary._updated = false;\n          }\n        }\n      });\n      for (var i = 0; i < collection_1.length; i++) {\n        indexes_1.push(collection_1[parseInt(i.toString(), 10)]);\n      }\n      var archiveOffset = void 0;\n      var archiveRef = void 0;\n      if (updatedCount > 0) {\n        archiveRef = this._getNextReference();\n        indexes_1.push(archiveRef.objectNumber, 2);\n        this._writeString(archiveXRef_1, data);\n        this._writeBytes(updatedStream_1, data);\n        var newDict = new _PdfDictionary(this);\n        newDict.set('Type', _PdfName.get('ObjStm'));\n        newDict.set('N', updatedCount);\n        newDict.set('First', archiveXRef_1.length);\n        newDict.set('Length', data.length);\n        var archiveStream = new _PdfStream(data, newDict, 0, data.length);\n        archiveOffset = currentLength + buffer.length;\n        var cipher_2;\n        if (this._encrypt) {\n          cipher_2 = this._encrypt._createCipherTransform(archiveRef.objectNumber, archiveRef.generationNumber);\n        }\n        this._writeObject(archiveStream, buffer, archiveRef, cipher_2);\n      }\n      var newRef = this._getNextReference();\n      var newStartXref = currentLength + buffer.length;\n      var newXref = new _PdfDictionary(this);\n      newXref.set('Type', _PdfName.get('XRef'));\n      newXref.set('Index', indexes_1);\n      newXref.set('W', [1, 3, 1]);\n      this._copyTrailer(newXref);\n      if (this._ids && this._ids.length > 0) {\n        newXref.update('ID', [this._ids[0], this._computeMessageDigest(newStartXref)]);\n      }\n      var newXrefData = [];\n      this._writeLong(0, 1, newXrefData);\n      this._writeLong(1, 3, newXrefData);\n      this._writeLong(-1, 1, newXrefData);\n      if (uncompressedCount > 0) {\n        for (var index = 0; index < uncompressedCount; index++) {\n          this._writeLong(1, 1, newXrefData);\n          this._writeLong(uncompressedOffsets_1[index], 3, newXrefData); // eslint-disable-line\n          this._writeLong(0, 1, newXrefData);\n        }\n      }\n      if (updatedCount > 0) {\n        for (var index = 0; index < updatedCount; index++) {\n          this._writeLong(2, 1, newXrefData);\n          this._writeLong(archiveRef.objectNumber, 3, newXrefData);\n          this._writeLong(index, 1, newXrefData);\n        }\n        this._writeLong(1, 1, newXrefData);\n        this._writeLong(archiveOffset, 3, newXrefData);\n        this._writeLong(0, 1, newXrefData);\n      }\n      this._writeLong(1, 1, newXrefData);\n      this._writeLong(newStartXref, 3, newXrefData);\n      this._writeLong(0, 1, newXrefData);\n      newXref.set('Length', newXrefData.length);\n      var newXrefStream = new _PdfStream(newXrefData, newXref, 0, newXrefData.length);\n      var cipher = void 0;\n      if (this._encrypt) {\n        cipher = this._encrypt._createCipherTransform(newRef.objectNumber, newRef.generationNumber);\n      }\n      this._writeObject(newXrefStream, buffer, newRef, cipher, true);\n      this._writeString(\"startxref\" + this._newLine + newStartXref + this._newLine + \"%%EOF\" + this._newLine, buffer);\n    } else {\n      var tempBuffer_1 = '';\n      this._cacheMap.forEach(function (value, key) {\n        var dictionary;\n        if (value instanceof _PdfDictionary) {\n          dictionary = value;\n        } else if (value instanceof _PdfBaseStream) {\n          dictionary = value.dictionary;\n        }\n        if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n          var offsetString = (currentLength + buffer.length).toString();\n          while (offsetString.length < 10) {\n            offsetString = '0' + offsetString;\n          }\n          var genString = key.generationNumber.toString();\n          while (genString.length < 5) {\n            genString = '0' + genString;\n          }\n          tempBuffer_1 += key.objectNumber + \" 1\" + _this._newLine + offsetString + \" \" + genString + \" n\" + _this._newLine;\n          updatedCount++;\n          _this._writeObject(value, buffer, key);\n        }\n      });\n      var newStartXref = buffer.length + currentLength;\n      this._writeString(\"xref\" + this._newLine + \"0 1\" + this._newLine + \"0000000000 65535 f\" + this._newLine, buffer);\n      if (updatedCount > 0) {\n        this._writeString(tempBuffer_1, buffer);\n      }\n      this._writeString(\"trailer\" + this._newLine, buffer);\n      var newXref = new _PdfDictionary(this);\n      this._copyTrailer(newXref);\n      this._writeDictionary(newXref, buffer, this._newLine);\n      this._writeString(\"startxref\" + this._newLine + newStartXref + this._newLine + \"%%EOF\" + this._newLine, buffer);\n    }\n    var array = new Uint8Array(this._stream.length + buffer.length);\n    array.set(this._stream.bytes);\n    array.set(buffer, this._stream.length);\n    return array;\n  };\n  _PdfCrossReference.prototype._copyTrailer = function (newXref) {\n    newXref.set('Size', this._nextReferenceNumber);\n    newXref.set('Prev', this._prevStartXref);\n    var root = this._trailer.getRaw('Root'); // eslint-disable-line\n    if (typeof root !== 'undefined' && root !== null) {\n      newXref.set('Root', root);\n    }\n    var info = this._trailer.getRaw('Info'); // eslint-disable-line\n    if (typeof info !== 'undefined' && info !== null) {\n      newXref.set('Info', info);\n    }\n    var encrypt = this._trailer.getRaw('Encrypt'); // eslint-disable-line\n    if (typeof encrypt !== 'undefined' && encrypt !== null) {\n      newXref.set('Encrypt', encrypt);\n    }\n  };\n  _PdfCrossReference.prototype._computeMessageDigest = function (size) {\n    var _this = this;\n    var time = Math.floor(Date.now() / 1000);\n    var buffer = [time.toString(), '', size.toString()];\n    var info = this._trailer.getRaw('Info');\n    var crossReferenceInfo = new _PdfDictionary();\n    if (info && info instanceof _PdfDictionary) {\n      info.forEach(function (key, value) {\n        if (value && typeof value === 'string') {\n          crossReferenceInfo.set(key, _stringToPdfString(value));\n        }\n      });\n    }\n    crossReferenceInfo.forEach(function (key, value) {\n      buffer.push(value);\n    });\n    var array = [];\n    buffer.forEach(function (str) {\n      _this._writeString(str, array);\n    });\n    return _bytesToString(new _MD5().hash(new Uint8Array(array)));\n  };\n  _PdfCrossReference.prototype._getNextReference = function () {\n    var reference = new _PdfReference(this._nextReferenceNumber++, 0);\n    reference._isNew = true;\n    return reference;\n  };\n  _PdfCrossReference.prototype._writeObject = function (obj, buffer, reference, transform, isCrossReference) {\n    if (reference && reference instanceof _PdfReference) {\n      this._writeString(reference.objectNumber + \" \" + reference.generationNumber + \" obj\" + this._newLine, buffer);\n    }\n    if (obj instanceof _PdfDictionary) {\n      this._writeDictionary(obj, buffer, this._newLine, transform, isCrossReference);\n    } else if (obj instanceof _PdfBaseStream) {\n      this._writeStream(obj, buffer, transform, isCrossReference);\n    }\n    if (reference && reference instanceof _PdfReference) {\n      this._writeString(\"endobj\" + this._newLine, buffer);\n    }\n  };\n  _PdfCrossReference.prototype._writeDictionary = function (dictionary, buffer, spaceChar, transform, isCrossReference) {\n    var _this = this;\n    if (dictionary._currentObj) {\n      dictionary._currentObj._beginSave();\n    }\n    if (dictionary._isFont) {\n      this._writeFontDictionary(dictionary);\n    }\n    this._writeString(\"<<\" + spaceChar, buffer);\n    dictionary.forEach(function (key, value) {\n      _this._writeString(\"/\" + _escapePdfName(key) + \" \", buffer);\n      _this._writeValue(value, buffer, transform, isCrossReference);\n      _this._writeString(spaceChar, buffer);\n    });\n    this._writeString(\">>\" + this._newLine, buffer);\n  };\n  _PdfCrossReference.prototype._writeFontDictionary = function (dictionary) {\n    if (dictionary.has('DescendantFonts')) {\n      var fonts = dictionary.get('DescendantFonts'); // eslint-disable-line\n      var reference = this._getNextReference();\n      this._cacheMap.set(reference, fonts);\n      dictionary.update('DescendantFonts', [reference]);\n    }\n    if (dictionary.has('ToUnicode')) {\n      var fonts = dictionary.get('ToUnicode'); // eslint-disable-line\n      var reference = this._getNextReference();\n      this._cacheMap.set(reference, fonts);\n      dictionary.update('ToUnicode', reference);\n    }\n    if (dictionary.has('FontFile2')) {\n      var fonts = dictionary.get('FontFile2'); // eslint-disable-line\n      var reference = this._getNextReference();\n      this._cacheMap.set(reference, fonts);\n      dictionary.update('FontFile2', reference);\n    }\n    if (dictionary.has('FontDescriptor')) {\n      var fonts = dictionary.get('FontDescriptor'); // eslint-disable-line\n      var reference = this._getNextReference();\n      this._cacheMap.set(reference, fonts);\n      dictionary.update('FontDescriptor', reference);\n    }\n  };\n  _PdfCrossReference.prototype._writeStream = function (stream, buffer, transform, isCrossReference) {\n    var streamBuffer = [];\n    var value = stream.getString();\n    if (!isCrossReference) {\n      var byteArray = [];\n      for (var i = 0; i < value.length; i++) {\n        byteArray.push(value.charCodeAt(i));\n      }\n      if (stream._isCompress) {\n        var dataArray = new Uint8Array(byteArray);\n        var sw = new CompressedStreamWriter();\n        sw.write(dataArray, 0, dataArray.length);\n        sw.close();\n        value = sw.getCompressedString;\n        stream.dictionary.update('Filter', _PdfName.get('FlateDecode'));\n      }\n      if (transform) {\n        value = transform.encryptString(value);\n      }\n    }\n    this._writeString(value, streamBuffer);\n    stream.dictionary.update('Length', streamBuffer.length);\n    this._writeDictionary(stream.dictionary, buffer, this._newLine, transform, isCrossReference);\n    this._writeString(\"stream\" + this._newLine, buffer);\n    this._writeBytes(streamBuffer, buffer);\n    this._writeString(this._newLine + \"endstream\" + this._newLine, buffer);\n  };\n  _PdfCrossReference.prototype._writeValue = function (value, buffer, transform, isCrossReference) {\n    if (value instanceof _PdfName) {\n      this._writeString(\"/\" + value.name, buffer);\n    } else if (value instanceof _PdfReference) {\n      this._writeString(value.toString() + \" R\", buffer);\n    } else if (Array.isArray(value)) {\n      this._writeString('[', buffer);\n      var first = true;\n      for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n        var val = value_1[_i];\n        if (!first) {\n          this._writeString(' ', buffer);\n        } else {\n          first = false;\n        }\n        this._writeValue(val, buffer, transform, isCrossReference);\n      }\n      this._writeString(']', buffer);\n    } else if (typeof value === 'string') {\n      if (!isCrossReference && transform) {\n        value = transform.encryptString(value);\n      }\n      this._writeString(\"(\" + this._escapeString(value) + \")\", buffer);\n    } else if (typeof value === 'number') {\n      this._writeString(_numberToString(value), buffer);\n    } else if (typeof value === 'boolean') {\n      this._writeString(value.toString(), buffer);\n    } else if (value instanceof _PdfDictionary) {\n      this._writeDictionary(value, buffer, this._newLine, transform, isCrossReference);\n    } else if (value instanceof _PdfBaseStream) {\n      this._writeStream(value, buffer, transform, isCrossReference);\n    } else if (value === null) {\n      this._writeString('null', buffer);\n    }\n  };\n  _PdfCrossReference.prototype._writeString = function (value, buffer) {\n    for (var i = 0; i < value.length; i++) {\n      buffer.push(value.charCodeAt(i) & 0xff);\n    }\n  };\n  _PdfCrossReference.prototype._writeBytes = function (data, buffer) {\n    for (var i = 0; i < data.length; i++) {\n      buffer.push(data[i]); // eslint-disable-line\n    }\n  };\n  _PdfCrossReference.prototype._writeLong = function (value, count, buffer) {\n    for (var i = count - 1; i >= 0; --i) {\n      buffer.push(value >> (i << 3) & 0xff);\n    }\n  };\n  _PdfCrossReference.prototype._escapeString = function (value) {\n    return value.replace(/([()\\\\\\n\\r])/g, function (substring) {\n      if (substring === '\\n') {\n        return '\\\\n';\n      } else if (substring === '\\r') {\n        return '\\\\r';\n      }\n      return \"\\\\\" + substring;\n    });\n  };\n  _PdfCrossReference.prototype._destroy = function () {\n    this._entries = undefined;\n    this._pendingRefs.clear();\n    this._pendingRefs = undefined;\n    this._cacheMap.clear();\n    this._pendingRefs = undefined;\n    this._root = undefined;\n    this._startXRefQueue = [];\n    this._startXRefQueue = undefined;\n    this._stream = undefined;\n    this._streamState = undefined;\n    this._tableState = undefined;\n    this._topDictionary = undefined;\n    this._trailer = undefined;\n    this._version = undefined;\n    this._crossReferencePosition = undefined;\n  };\n  return _PdfCrossReference;\n}();\nexport { _PdfCrossReference };\nvar _PdfObjectInformation = /** @class */function () {\n  function _PdfObjectInformation() {}\n  return _PdfObjectInformation;\n}();\nvar _PdfCrossTableState = /** @class */function () {\n  function _PdfCrossTableState() {}\n  return _PdfCrossTableState;\n}();\nvar _PdfStreamState = /** @class */function () {\n  function _PdfStreamState() {}\n  return _PdfStreamState;\n}();","map":{"version":3,"names":["_PdfStream","_PdfDictionary","_PdfReferenceSet","_isCommand","_PdfReference","_PdfName","BaseException","FormatError","_escapePdfName","_bytesToString","ParserEndOfFileException","_numberToString","_stringToPdfString","_PdfParser","_PdfLexicalOperator","_PdfBaseStream","PdfCrossReferenceType","_MD5","_PdfEncryptor","CompressedStreamWriter","_PdfCrossReference","document","password","_version","_newLine","_password","_document","_stream","_entries","_crossReferencePosition","Object","create","_cacheMap","Map","_pendingRefs","prototype","_setStartXRef","startXRef","_startXRefQueue","_prevStartXref","_parse","recoveryMode","trailerDictionary","_readXRef","_indexObjects","assignXref","_nextReferenceNumber","get","_trailer","encrypt","_isEncrypted","_ids","_permissionFlags","fileId","length","suppressEncryption","_encrypt","_fileStructure","_crossReferenceType","stream","_isUserPassword","_encryptOnlyAttachment","_hasUserPasswordOnly","_encryptMetaData","has","hasRoot","root","pagesEntry","_root","ex","_getEntry","i","xrefEntry","free","offset","_fetch","ref","entry","Error","objectNumber","cacheEntry","objId","set","remove","put","uncompressed","_fetchUncompressed","_fetchCompressed","reference","generationNumber","gen","makeSubStream","start","undefined","parser","obj1","getObject","obj2","obj3","_createCipherTransform","toString","dictionary","tableOffset","first","n","Number","isInteger","nums","Array","offsets","value","entries","length_1","obj","result","startXRefParsedCache","Set","shift","add","position","table","_processXRefTable","_topDictionary","push","command","_processXRefStream","e","_readToken","data","lf","cr","lt","token","ch","String","fromCharCode","_skipUntil","what","dataLength","skipped","tab","space","percent","objRegExp","endobjRegExp","nestedObjRegExp","checkContentLength","trailerBytes","Uint8Array","startxrefBytes","objBytes","xrefBytes","clear","buffer","getBytes","trailers","crossReferencePosition","m","startsWith","test","exec","parseInt","contentLength","startPos","updateEntries","subStream","lexicalOperator","info","_PdfObjectInformation","endPos","checkPos","Math","max","tokenStr","subarray","objToken","content","xrefTagOffset","trailerDict","rootDict","pagesDict","pagesCount","_tableState","tableState","_PdfCrossTableState","entryNum","streamPos","parserBuf1","parserBuf2","second","_readXRefTable","topDictionary","firstEntryNum","entryCount","count","type","_streamState","streamParameters","streamState","_PdfStreamState","index","getArray","entryRanges","byteWidths","_readXRefStream","typeFieldWidth","offsetFieldWidth","generationFieldWidth","generation","j","typeByte","getByte","offsetByte","generationByte","splice","_getCatalogObj","_save","_this","currentLength","charCodeAt","_writeString","updatedCount","uncompressedCount","updatedStream_1","archiveXRef_1","indexes_1","collection_1","uncompressedOffsets_1","forEach","key","_updated","isCatalog","_allowCatalog","cipher_1","_writeObject","archiveOffset","archiveRef","_getNextReference","_writeBytes","newDict","archiveStream","cipher_2","newRef","newStartXref","newXref","_copyTrailer","update","_computeMessageDigest","newXrefData","_writeLong","newXrefStream","cipher","tempBuffer_1","offsetString","genString","_writeDictionary","array","bytes","getRaw","size","time","floor","Date","now","crossReferenceInfo","str","hash","_isNew","transform","isCrossReference","_writeStream","spaceChar","_currentObj","_beginSave","_isFont","_writeFontDictionary","_writeValue","fonts","streamBuffer","getString","byteArray","_isCompress","dataArray","sw","write","close","getCompressedString","encryptString","name","isArray","_i","value_1","val","_escapeString","replace","substring","_destroy"],"sources":["/Users/saleem/Desktop/KClient/Web App/Ver_3.6/User Interface/website_Source files/node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-cross-reference.js"],"sourcesContent":["import { _PdfStream } from './base-stream';\nimport { _PdfDictionary, _PdfReferenceSet, _isCommand, _PdfReference, _PdfName } from './pdf-primitives';\nimport { BaseException, FormatError, _escapePdfName, _bytesToString, ParserEndOfFileException, _numberToString, _stringToPdfString } from './utils';\nimport { _PdfParser, _PdfLexicalOperator } from './pdf-parser';\nimport { _PdfBaseStream } from './base-stream';\nimport { PdfCrossReferenceType } from './enumerator';\nimport { _MD5, _PdfEncryptor } from './security/encryptor';\nimport { CompressedStreamWriter } from '@syncfusion/ej2-compression';\nvar _PdfCrossReference = /** @class */ (function () {\n    function _PdfCrossReference(document, password) {\n        this._version = '';\n        this._newLine = '\\r\\n';\n        this._password = password;\n        this._document = document;\n        this._stream = document._stream;\n        this._entries = [];\n        this._crossReferencePosition = Object.create(null);\n        this._cacheMap = new Map(); // eslint-disable-line\n        this._pendingRefs = new _PdfReferenceSet();\n    }\n    _PdfCrossReference.prototype._setStartXRef = function (startXRef) {\n        this._startXRefQueue = [startXRef];\n        this._prevStartXref = startXRef;\n    };\n    _PdfCrossReference.prototype._parse = function (recoveryMode) {\n        var trailerDictionary;\n        if (!recoveryMode) {\n            trailerDictionary = this._readXRef();\n        }\n        else {\n            trailerDictionary = this._indexObjects();\n        }\n        trailerDictionary.assignXref(this);\n        this._nextReferenceNumber = trailerDictionary.get('Size');\n        this._trailer = trailerDictionary;\n        var encrypt = trailerDictionary.get('Encrypt');\n        if (encrypt) {\n            this._document._isEncrypted = true;\n            this._ids = trailerDictionary.get('ID');\n            this._permissionFlags = encrypt.get('P');\n            var fileId = this._ids && this._ids.length ? this._ids[0] : '';\n            encrypt.suppressEncryption = true;\n            this._encrypt = new _PdfEncryptor(encrypt, fileId, this._password);\n            this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.stream;\n            this._document._isUserPassword = this._encrypt._isUserPassword;\n            this._document._encryptOnlyAttachment = this._encrypt._encryptOnlyAttachment;\n            if (this._encrypt._encryptOnlyAttachment) {\n                this._document._hasUserPasswordOnly = true;\n                this._document._encryptMetaData = false;\n            }\n            else {\n                this._document._hasUserPasswordOnly = this._encrypt._hasUserPasswordOnly;\n                this._document._encryptMetaData = encrypt.has('EncryptMetadata') ? encrypt.get('EncryptMetadata') : true;\n            }\n        }\n        var hasRoot = false;\n        try {\n            var root = trailerDictionary.get('Root');\n            if (root) {\n                var pagesEntry = root.get('Pages');\n                if (pagesEntry) {\n                    this._root = root;\n                    hasRoot = true;\n                }\n            }\n        }\n        catch (ex) {\n            throw new BaseException('Invalid cross reference', 'InvalidXRef');\n        }\n        if (!hasRoot) {\n            if (!recoveryMode) {\n                throw new BaseException('Invalid cross reference', 'XRefParseException');\n            }\n            else {\n                throw new BaseException('Invalid cross reference', 'InvalidXRef');\n            }\n        }\n    };\n    _PdfCrossReference.prototype._getEntry = function (i) {\n        var xrefEntry = this._entries[i]; // eslint-disable-line\n        if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {\n            return xrefEntry;\n        }\n        return null;\n    };\n    _PdfCrossReference.prototype._fetch = function (ref, suppressEncryption) {\n        var entry; // eslint-disable-line\n        if (!(ref instanceof _PdfReference)) {\n            throw new Error('ref object is not a reference');\n        }\n        var objectNumber = ref.objectNumber;\n        var cacheEntry = this._cacheMap.get(ref); // eslint-disable-line\n        if (typeof cacheEntry !== 'undefined') {\n            if (cacheEntry instanceof _PdfDictionary && !cacheEntry.objId) {\n                cacheEntry.objId = objectNumber;\n            }\n            return cacheEntry;\n        }\n        var xrefEntry = this._getEntry(objectNumber);\n        if (xrefEntry === null) {\n            this._cacheMap.set(ref, xrefEntry);\n            return xrefEntry;\n        }\n        if (this._pendingRefs.has(ref)) {\n            this._pendingRefs.remove(ref);\n            throw new Error('circular reference');\n        }\n        this._pendingRefs.put(ref);\n        try {\n            if (xrefEntry.uncompressed) {\n                entry = this._fetchUncompressed(ref, xrefEntry, suppressEncryption);\n            }\n            else {\n                entry = this._fetchCompressed(ref, xrefEntry);\n            }\n            this._pendingRefs.remove(ref);\n        }\n        catch (ex) {\n            this._pendingRefs.remove(ref);\n            throw ex;\n        }\n        return entry;\n    };\n    _PdfCrossReference.prototype._fetchUncompressed = function (reference, xrefEntry, suppressEncryption) {\n        var generationNumber = reference.generationNumber;\n        var objectNumber = reference.objectNumber;\n        if (xrefEntry.gen !== generationNumber) {\n            throw new BaseException(\"Inconsistent generation in XRef: \" + reference, 'XRefEntryException');\n        }\n        var stream = this._stream.makeSubStream(xrefEntry.offset + this._stream.start, undefined);\n        var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);\n        var obj1 = parser.getObject();\n        var obj2 = parser.getObject();\n        var obj3 = parser.getObject();\n        if (obj1 !== objectNumber || obj2 !== generationNumber || typeof obj3 === 'undefined') {\n            throw new BaseException(\"Bad (uncompressed) XRef entry: \" + reference, 'XRefEntryException');\n        }\n        var entry; // eslint-disable-line\n        if (this._encrypt && !suppressEncryption) {\n            entry = parser.getObject(this._encrypt._createCipherTransform(reference.objectNumber, reference.generationNumber));\n        }\n        else {\n            entry = parser.getObject();\n        }\n        if (!(entry instanceof _PdfBaseStream)) {\n            this._cacheMap.set(reference, entry);\n        }\n        if (entry instanceof _PdfDictionary) {\n            entry.objId = reference.toString();\n        }\n        else if (entry instanceof _PdfBaseStream) {\n            entry.dictionary.objId = reference.toString();\n        }\n        return entry;\n    };\n    _PdfCrossReference.prototype._fetchCompressed = function (ref, xrefEntry) {\n        var tableOffset = xrefEntry.offset;\n        var stream = this._fetch(_PdfReference.get(tableOffset, 0));\n        if (typeof stream === 'undefined') {\n            throw new FormatError('bad ObjStm stream');\n        }\n        var first = stream.dictionary.get('First');\n        var n = stream.dictionary.get('N');\n        var gen = ref.generationNumber;\n        if (!Number.isInteger(first) || !Number.isInteger(n)) {\n            throw new FormatError('invalid first and n parameters for ObjStm stream');\n        }\n        var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);\n        var nums = new Array(n);\n        var offsets = new Array(n);\n        for (var i = 0; i < n; ++i) {\n            var value = parser.getObject();\n            if (!Number.isInteger(value)) {\n                throw new FormatError(\"invalid object number in the ObjStm stream: \" + value);\n            }\n            var offset = parser.getObject();\n            if (!Number.isInteger(offset)) {\n                throw new FormatError(\"invalid object offset in the ObjStm stream: \" + offset);\n            }\n            nums[i] = value; // eslint-disable-line\n            offsets[i] = offset; // eslint-disable-line\n        }\n        var start = (stream.start || 0) + first;\n        var entries = new Array(n); // eslint-disable-line\n        for (var i = 0; i < n; ++i) {\n            var length_1 = (i < n - 1 ? (offsets[i + 1] - offsets[i]) : undefined); // eslint-disable-line\n            if (length_1 < 0) {\n                throw new FormatError('Invalid offset in the ObjStm stream.');\n            }\n            parser = new _PdfParser(new _PdfLexicalOperator(stream.makeSubStream(start + offsets[i], length_1, stream.dictionary)), this, true); // eslint-disable-line\n            var obj = parser.getObject(); // eslint-disable-line\n            entries[i] = obj; // eslint-disable-line\n            if (obj instanceof _PdfBaseStream) {\n                continue;\n            }\n            var value = nums[i]; // eslint-disable-line\n            var entry = this._entries[value]; // eslint-disable-line\n            if (entry && entry.offset === tableOffset && entry.gen === i) {\n                var objId = value + \" \" + gen;\n                this._cacheMap.set(_PdfReference.get(value, gen), obj);\n                if (obj instanceof _PdfDictionary) {\n                    obj.objId = objId;\n                }\n            }\n        }\n        var result = entries[xrefEntry.gen]; // eslint-disable-line\n        if (typeof result === 'undefined') {\n            throw new BaseException(\"Bad (compressed) XRef entry: \" + ref, 'XRefEntryException');\n        }\n        return result;\n    };\n    _PdfCrossReference.prototype._readXRef = function (recoveryMode) {\n        if (recoveryMode === void 0) { recoveryMode = false; }\n        var stream = this._stream;\n        var startXRefParsedCache = new Set();\n        try {\n            while (this._startXRefQueue.length) {\n                var startXRef = this._startXRefQueue[0];\n                if (this._prevStartXref < startXRef) {\n                    this._prevStartXref = startXRef;\n                }\n                if (startXRefParsedCache.has(startXRef)) {\n                    this._startXRefQueue.shift();\n                    continue;\n                }\n                startXRefParsedCache.add(startXRef);\n                stream.position = startXRef + stream.start;\n                var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);\n                var obj = parser.getObject(); // eslint-disable-line\n                var dictionary = void 0;\n                if (_isCommand(obj, 'xref')) {\n                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {\n                        this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.table;\n                    }\n                    dictionary = this._processXRefTable(parser);\n                    if (!this._topDictionary) {\n                        this._topDictionary = dictionary;\n                    }\n                    obj = dictionary.get('XRefStm');\n                    if (Number.isInteger(obj)) {\n                        var position = obj; // eslint-disable-line\n                        if (!(position in this._crossReferencePosition)) {\n                            this._crossReferencePosition[position] = 1; // eslint-disable-line\n                            this._startXRefQueue.push(position);\n                        }\n                    }\n                }\n                else if (Number.isInteger(obj)) {\n                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {\n                        this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.stream;\n                    }\n                    var gen = parser.getObject();\n                    var command = parser.getObject();\n                    obj = parser.getObject();\n                    if (typeof gen === 'undefined' ||\n                        !Number.isInteger(gen) ||\n                        !_isCommand(command, 'obj') ||\n                        !(obj instanceof _PdfBaseStream)) {\n                        throw new FormatError('Invalid cross reference stream');\n                    }\n                    dictionary = this._processXRefStream(obj);\n                    if (!this._topDictionary) {\n                        this._topDictionary = dictionary;\n                    }\n                    if (!dictionary) {\n                        throw new FormatError('Failed to read XRef stream');\n                    }\n                }\n                else {\n                    throw new FormatError('Invalid XRef stream header');\n                }\n                obj = dictionary.get('Prev');\n                if (Number.isInteger(obj)) {\n                    this._startXRefQueue.push(obj);\n                }\n                else if (obj instanceof _PdfReference) {\n                    this._startXRefQueue.push(obj.objectNumber);\n                }\n                this._startXRefQueue.shift();\n            }\n            return this._topDictionary;\n        }\n        catch (e) {\n            this._startXRefQueue.shift();\n        }\n        if (recoveryMode) {\n            return undefined;\n        }\n        throw new BaseException('Invalid cross reference', 'XRefParseException');\n    };\n    _PdfCrossReference.prototype._readToken = function (data, offset) {\n        var lf = 0xa;\n        var cr = 0xd;\n        var lt = 0x3c;\n        var token = '';\n        var ch = data[offset]; // eslint-disable-line\n        while (ch !== lf && ch !== cr && ch !== lt) {\n            if (++offset >= data.length) {\n                break;\n            }\n            token += String.fromCharCode(ch);\n            ch = data[offset]; // eslint-disable-line\n        }\n        return token;\n    };\n    _PdfCrossReference.prototype._skipUntil = function (data, offset, what) {\n        var length = what.length;\n        var dataLength = data.length;\n        var skipped = 0;\n        while (offset < dataLength) {\n            var i = 0;\n            while (i < length && data[offset + i] === what[i]) { // eslint-disable-line\n                ++i;\n            }\n            if (i >= length) {\n                break;\n            }\n            offset++;\n            skipped++;\n        }\n        return skipped;\n    };\n    _PdfCrossReference.prototype._indexObjects = function () {\n        var tab = 0x9;\n        var lf = 0xa;\n        var cr = 0xd;\n        var space = 0x20;\n        var percent = 0x25;\n        var objRegExp = /^(\\d+)\\s+(\\d+)\\s+obj\\b/;\n        var endobjRegExp = /\\bendobj[\\b\\s]$/;\n        var nestedObjRegExp = /\\s+(\\d+\\s+\\d+\\s+obj[\\b\\s<])$/;\n        var checkContentLength = 25;\n        var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);\n        var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);\n        var objBytes = new Uint8Array([111, 98, 106]);\n        var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);\n        this._entries.length = 0;\n        this._cacheMap.clear();\n        var stream = this._stream;\n        stream.position = 0;\n        var buffer = stream.getBytes();\n        var length = buffer.length;\n        var position = stream.start;\n        var trailers = [];\n        var crossReferencePosition = [];\n        while (position < length) {\n            var ch = buffer[position]; // eslint-disable-line\n            if (ch === tab || ch === lf || ch === cr || ch === space) {\n                ++position;\n                continue;\n            }\n            if (ch === percent) {\n                do {\n                    ++position;\n                    if (position >= length) {\n                        break;\n                    }\n                    ch = buffer[position]; // eslint-disable-line\n                } while (ch !== lf && ch !== cr);\n                continue;\n            }\n            var token = this._readToken(buffer, position);\n            var m = void 0; // eslint-disable-line\n            if (token.startsWith('xref') && (token.length === 4 || /\\s/.test(token[4]))) {\n                position += this._skipUntil(buffer, position, trailerBytes);\n                trailers.push(position);\n                position += this._skipUntil(buffer, position, startxrefBytes);\n            }\n            else {\n                m = objRegExp.exec(token);\n                if (m) {\n                    var objectNumber = Number.parseInt(m[1]) | 0; // eslint-disable-line\n                    var gen = Number.parseInt(m[2]) | 0; // eslint-disable-line\n                    var contentLength = void 0;\n                    var startPos = position + token.length;\n                    var updateEntries = false;\n                    if (!this._entries[objectNumber]) { // eslint-disable-line\n                        updateEntries = true;\n                    }\n                    else if (this._entries[objectNumber].gen === gen) { // eslint-disable-line\n                        try {\n                            var subStream = stream.makeSubStream(startPos, stream.length - startPos);\n                            var lexicalOperator = new _PdfLexicalOperator(subStream);\n                            var parser = new _PdfParser(lexicalOperator, null);\n                            parser.getObject();\n                            updateEntries = true;\n                        }\n                        catch (ex) {\n                            updateEntries = !(ex instanceof ParserEndOfFileException);\n                        }\n                    }\n                    if (updateEntries) {\n                        var info = new _PdfObjectInformation();\n                        info.offset = position - stream.start;\n                        info.gen = gen;\n                        info.uncompressed = true;\n                        this._entries[objectNumber] = info; // eslint-disable-line\n                    }\n                    while (startPos < buffer.length) {\n                        var endPos = startPos + this._skipUntil(buffer, startPos, objBytes) + 4;\n                        contentLength = endPos - position;\n                        var checkPos = Math.max(endPos - checkContentLength, startPos);\n                        var tokenStr = _bytesToString(buffer.subarray(checkPos, endPos));\n                        if (endobjRegExp.test(tokenStr)) {\n                            break;\n                        }\n                        else {\n                            var objToken = nestedObjRegExp.exec(tokenStr); // eslint-disable-line\n                            if (objToken && objToken[1]) {\n                                contentLength -= objToken[1].length;\n                                break;\n                            }\n                        }\n                        startPos = endPos;\n                    }\n                    var content = buffer.subarray(position, position + contentLength);\n                    var xrefTagOffset = this._skipUntil(content, 0, xrefBytes);\n                    if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {\n                        crossReferencePosition.push(position - stream.start);\n                        this._crossReferencePosition[position - stream.start] = 1;\n                    }\n                    position += contentLength;\n                }\n                else if (token.startsWith('trailer') && (token.length === 7 || /\\s/.test(token[7]))) {\n                    trailers.push(position);\n                    position += this._skipUntil(buffer, position, startxrefBytes);\n                }\n                else {\n                    position += token.length + 1;\n                }\n            }\n        }\n        for (var i = 0; i < crossReferencePosition.length; ++i) {\n            this._startXRefQueue.push(crossReferencePosition[i]); // eslint-disable-line\n            this._readXRef(true);\n        }\n        var trailerDict;\n        for (var i = 0; i < trailers.length; ++i) {\n            stream.position = trailers[i]; // eslint-disable-line\n            var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true, true);\n            var obj = parser.getObject(); // eslint-disable-line\n            if (!_isCommand(obj, 'trailer')) {\n                continue;\n            }\n            var dictionary = parser.getObject(); // eslint-disable-line\n            if (!(dictionary instanceof _PdfDictionary)) {\n                continue;\n            }\n            try {\n                var rootDict = dictionary.get('Root'); // eslint-disable-line\n                if (!(rootDict instanceof _PdfDictionary)) {\n                    continue;\n                }\n                var pagesDict = rootDict.get('Pages'); // eslint-disable-line\n                if (!(pagesDict instanceof _PdfDictionary)) {\n                    continue;\n                }\n                var pagesCount = pagesDict.get('Count');\n                if (typeof pagesCount === 'undefined' || !Number.isInteger(pagesCount)) {\n                    continue;\n                }\n            }\n            catch (ex) {\n                continue;\n            }\n            if (dictionary.has('ID')) {\n                return dictionary;\n            }\n            trailerDict = dictionary;\n        }\n        if (trailerDict) {\n            return trailerDict;\n        }\n        if (this._topDictionary) {\n            return this._topDictionary;\n        }\n        throw new BaseException('Invalid PDF structure.', 'InvalidPDFException');\n    };\n    _PdfCrossReference.prototype._processXRefTable = function (parser) {\n        if (typeof this._tableState === 'undefined') {\n            var tableState = new _PdfCrossTableState();\n            tableState.entryNum = 0;\n            tableState.streamPos = parser.lexicalOperator.stream.position;\n            tableState.parserBuf1 = parser.first;\n            tableState.parserBuf2 = parser.second;\n            this._tableState = tableState;\n        }\n        var obj = this._readXRefTable(parser);\n        if (!_isCommand(obj, 'trailer')) {\n            throw new FormatError('Invalid XRef table: could not find trailer dictionary');\n        }\n        var topDictionary = parser.getObject(); // eslint-disable-line\n        var dictionary;\n        if (topDictionary) {\n            if (topDictionary instanceof _PdfDictionary) {\n                dictionary = topDictionary;\n            }\n            else if (topDictionary instanceof _PdfBaseStream && topDictionary.dictionary) {\n                dictionary = topDictionary.dictionary;\n            }\n        }\n        if (!dictionary) {\n            throw new FormatError('Invalid cross reference: could not parse trailer dictionary');\n        }\n        this._tableState = undefined;\n        return dictionary;\n    };\n    _PdfCrossReference.prototype._readXRefTable = function (parser) {\n        var stream = parser.lexicalOperator.stream;\n        stream.position = this._tableState.streamPos;\n        parser.first = this._tableState.parserBuf1;\n        parser.second = this._tableState.parserBuf2;\n        var obj; // eslint-disable-line\n        while (true) { // eslint-disable-line\n            if (typeof this._tableState.firstEntryNum === 'undefined' || typeof this._tableState.entryCount === 'undefined') {\n                obj = parser.getObject();\n                if (_isCommand(obj, 'trailer')) {\n                    break;\n                }\n                this._tableState.firstEntryNum = obj;\n                this._tableState.entryCount = parser.getObject();\n            }\n            var first = this._tableState.firstEntryNum;\n            var count = this._tableState.entryCount;\n            if (!Number.isInteger(first) || !Number.isInteger(count)) {\n                throw new FormatError('Invalid cross reference: wrong types in subsection header');\n            }\n            for (var i = this._tableState.entryNum; i < count; i++) {\n                this._tableState.streamPos = stream.position;\n                this._tableState.entryNum = i;\n                this._tableState.parserBuf1 = parser.first;\n                this._tableState.parserBuf2 = parser.second;\n                var entry = new _PdfObjectInformation();\n                entry.offset = parser.getObject();\n                entry.gen = parser.getObject();\n                var type = parser.getObject();\n                if (type) {\n                    switch (type.command) {\n                        case 'f':\n                            entry.free = true;\n                            break;\n                        case 'n':\n                            entry.uncompressed = true;\n                            break;\n                    }\n                }\n                if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {\n                    throw new FormatError(\"Invalid entry in cross reference subsection: \" + first + \", \" + count);\n                }\n                if (i === 0 && entry.free && first === 1) {\n                    first = 0;\n                }\n                if (!this._entries[i + first]) {\n                    this._entries[i + first] = entry;\n                }\n            }\n            this._tableState.entryNum = 0;\n            this._tableState.streamPos = stream.position;\n            this._tableState.parserBuf1 = parser.first;\n            this._tableState.parserBuf2 = parser.second;\n            this._tableState.firstEntryNum = undefined;\n            this._tableState.entryCount = undefined;\n        }\n        if (this._entries[0] && !this._entries[0].free) {\n            throw new FormatError('Invalid XRef table: unexpected first object');\n        }\n        return obj;\n    };\n    _PdfCrossReference.prototype._processXRefStream = function (stream) {\n        if (typeof this._streamState === 'undefined') {\n            var streamParameters = stream.dictionary;\n            var streamState = new _PdfStreamState();\n            var index = streamParameters.getArray('Index');\n            if (!index) {\n                index = [0, streamParameters.get('Size')];\n            }\n            streamState.entryRanges = index;\n            streamState.byteWidths = streamParameters.getArray('W');\n            streamState.entryNum = 0;\n            streamState.streamPos = stream.position;\n            this._streamState = streamState;\n        }\n        this._readXRefStream(stream);\n        this._streamState = undefined;\n        return stream.dictionary;\n    };\n    _PdfCrossReference.prototype._readXRefStream = function (stream) {\n        stream.position = this._streamState.streamPos;\n        var typeFieldWidth = this._streamState.byteWidths[0];\n        var offsetFieldWidth = this._streamState.byteWidths[1];\n        var generationFieldWidth = this._streamState.byteWidths[2];\n        var entryRanges = this._streamState.entryRanges;\n        while (entryRanges.length > 0) {\n            var first = entryRanges[0];\n            var n = entryRanges[1];\n            if (!Number.isInteger(first) || !Number.isInteger(n)) {\n                throw new FormatError(\"Invalid XRef range fields: \" + first + \", \" + n);\n            }\n            if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {\n                throw new FormatError(\"Invalid XRef entry fields length: \" + first + \", \" + n);\n            }\n            for (var i = this._streamState.entryNum; i < n; ++i) {\n                this._streamState.entryNum = i;\n                this._streamState.streamPos = stream.position;\n                var type = 0;\n                var offset = 0;\n                var generation = 0;\n                for (var j = 0; j < typeFieldWidth; ++j) {\n                    var typeByte = stream.getByte();\n                    if (typeByte === -1) {\n                        throw new FormatError('invalid cross reference byte width type.');\n                    }\n                    type = (type << 8) | typeByte;\n                }\n                if (typeFieldWidth === 0) {\n                    type = 1;\n                }\n                for (var j = 0; j < offsetFieldWidth; ++j) {\n                    var offsetByte = stream.getByte();\n                    if (offsetByte === -1) {\n                        throw new FormatError('invalid cross reference byte width offset.');\n                    }\n                    offset = (offset << 8) | offsetByte;\n                }\n                for (var j = 0; j < generationFieldWidth; ++j) {\n                    var generationByte = stream.getByte();\n                    if (generationByte === -1) {\n                        throw new FormatError('invalid cross reference byte width generation.');\n                    }\n                    generation = (generation << 8) | generationByte;\n                }\n                var entry = new _PdfObjectInformation();\n                entry.offset = offset;\n                entry.gen = generation;\n                switch (type) {\n                    case 0:\n                        entry.free = true;\n                        break;\n                    case 1:\n                        entry.uncompressed = true;\n                        break;\n                    case 2:\n                        break;\n                    default:\n                        throw new FormatError(\"Invalid XRef entry type: \" + type);\n                }\n                if (!this._entries[first + i]) {\n                    this._entries[first + i] = entry;\n                }\n            }\n            this._streamState.entryNum = 0;\n            this._streamState.streamPos = stream.position;\n            entryRanges.splice(0, 2);\n        }\n    };\n    _PdfCrossReference.prototype._getCatalogObj = function () {\n        return this._root;\n    };\n    _PdfCrossReference.prototype._save = function () {\n        var _this = this;\n        var currentLength = this._stream.length;\n        var buffer = [this._newLine.charCodeAt(0), this._newLine.charCodeAt(1), 37, 80, 68, 70, 45];\n        this._writeString(\"\" + this._version + this._newLine, buffer);\n        buffer.push(0x25, 0x83, 0x92, 0xfa, 0xfe);\n        this._writeString(this._newLine, buffer);\n        var updatedCount = 0;\n        var uncompressedCount = 0;\n        if (this._document._fileStructure._crossReferenceType === PdfCrossReferenceType.stream) {\n            var data = [];\n            var updatedStream_1 = [];\n            var archiveXRef_1 = '';\n            var indexes_1 = [];\n            indexes_1.push(0, 1);\n            var collection_1 = [];\n            var uncompressedOffsets_1 = [];\n            this._cacheMap.forEach(function (value, key) {\n                var dictionary;\n                if (value instanceof _PdfBaseStream) {\n                    dictionary = value.dictionary;\n                }\n                if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n                    indexes_1.push(key.objectNumber, 1);\n                    uncompressedOffsets_1.push(currentLength + buffer.length);\n                    var cipher_1;\n                    if (_this._encrypt) {\n                        cipher_1 = _this._encrypt._createCipherTransform(key.objectNumber, key.generationNumber);\n                    }\n                    _this._writeObject(value, buffer, key, cipher_1);\n                    uncompressedCount++;\n                    dictionary._updated = false;\n                }\n            });\n            this._cacheMap.forEach(function (value, key) {\n                if (value instanceof _PdfDictionary) {\n                    if (value._updated && (!value.isCatalog || _this._allowCatalog)) {\n                        archiveXRef_1 += key.objectNumber + \" \" + updatedStream_1.length + _this._newLine;\n                        collection_1.push(key.objectNumber, 1);\n                        updatedCount++;\n                        _this._writeObject(value, updatedStream_1);\n                    }\n                }\n                else if (value instanceof _PdfBaseStream) {\n                    var dictionary = value.dictionary;\n                    if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n                        indexes_1.push(key.objectNumber, 1);\n                        uncompressedOffsets_1.push(currentLength + buffer.length);\n                        _this._writeObject(value, buffer, key);\n                        uncompressedCount++;\n                        dictionary._updated = false;\n                    }\n                }\n            });\n            for (var i = 0; i < collection_1.length; i++) {\n                indexes_1.push(collection_1[parseInt(i.toString(), 10)]);\n            }\n            var archiveOffset = void 0;\n            var archiveRef = void 0;\n            if (updatedCount > 0) {\n                archiveRef = this._getNextReference();\n                indexes_1.push(archiveRef.objectNumber, 2);\n                this._writeString(archiveXRef_1, data);\n                this._writeBytes(updatedStream_1, data);\n                var newDict = new _PdfDictionary(this);\n                newDict.set('Type', _PdfName.get('ObjStm'));\n                newDict.set('N', updatedCount);\n                newDict.set('First', archiveXRef_1.length);\n                newDict.set('Length', data.length);\n                var archiveStream = new _PdfStream(data, newDict, 0, data.length);\n                archiveOffset = currentLength + buffer.length;\n                var cipher_2;\n                if (this._encrypt) {\n                    cipher_2 = this._encrypt._createCipherTransform(archiveRef.objectNumber, archiveRef.generationNumber);\n                }\n                this._writeObject(archiveStream, buffer, archiveRef, cipher_2);\n            }\n            var newRef = this._getNextReference();\n            var newStartXref = currentLength + buffer.length;\n            var newXref = new _PdfDictionary(this);\n            newXref.set('Type', _PdfName.get('XRef'));\n            newXref.set('Index', indexes_1);\n            newXref.set('W', [1, 3, 1]);\n            this._copyTrailer(newXref);\n            if (this._ids && this._ids.length > 0) {\n                newXref.update('ID', [this._ids[0], this._computeMessageDigest(newStartXref)]);\n            }\n            var newXrefData = [];\n            this._writeLong(0, 1, newXrefData);\n            this._writeLong(1, 3, newXrefData);\n            this._writeLong(-1, 1, newXrefData);\n            if (uncompressedCount > 0) {\n                for (var index = 0; index < uncompressedCount; index++) {\n                    this._writeLong(1, 1, newXrefData);\n                    this._writeLong(uncompressedOffsets_1[index], 3, newXrefData); // eslint-disable-line\n                    this._writeLong(0, 1, newXrefData);\n                }\n            }\n            if (updatedCount > 0) {\n                for (var index = 0; index < updatedCount; index++) {\n                    this._writeLong(2, 1, newXrefData);\n                    this._writeLong(archiveRef.objectNumber, 3, newXrefData);\n                    this._writeLong(index, 1, newXrefData);\n                }\n                this._writeLong(1, 1, newXrefData);\n                this._writeLong(archiveOffset, 3, newXrefData);\n                this._writeLong(0, 1, newXrefData);\n            }\n            this._writeLong(1, 1, newXrefData);\n            this._writeLong(newStartXref, 3, newXrefData);\n            this._writeLong(0, 1, newXrefData);\n            newXref.set('Length', newXrefData.length);\n            var newXrefStream = new _PdfStream(newXrefData, newXref, 0, newXrefData.length);\n            var cipher = void 0;\n            if (this._encrypt) {\n                cipher = this._encrypt._createCipherTransform(newRef.objectNumber, newRef.generationNumber);\n            }\n            this._writeObject(newXrefStream, buffer, newRef, cipher, true);\n            this._writeString(\"startxref\" + this._newLine + newStartXref + this._newLine + \"%%EOF\" + this._newLine, buffer);\n        }\n        else {\n            var tempBuffer_1 = '';\n            this._cacheMap.forEach(function (value, key) {\n                var dictionary;\n                if (value instanceof _PdfDictionary) {\n                    dictionary = value;\n                }\n                else if (value instanceof _PdfBaseStream) {\n                    dictionary = value.dictionary;\n                }\n                if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n                    var offsetString = (currentLength + buffer.length).toString();\n                    while (offsetString.length < 10) {\n                        offsetString = '0' + offsetString;\n                    }\n                    var genString = key.generationNumber.toString();\n                    while (genString.length < 5) {\n                        genString = '0' + genString;\n                    }\n                    tempBuffer_1 += key.objectNumber + \" 1\" + _this._newLine + offsetString + \" \" + genString + \" n\" + _this._newLine;\n                    updatedCount++;\n                    _this._writeObject(value, buffer, key);\n                }\n            });\n            var newStartXref = buffer.length + currentLength;\n            this._writeString(\"xref\" + this._newLine + \"0 1\" + this._newLine + \"0000000000 65535 f\" + this._newLine, buffer);\n            if (updatedCount > 0) {\n                this._writeString(tempBuffer_1, buffer);\n            }\n            this._writeString(\"trailer\" + this._newLine, buffer);\n            var newXref = new _PdfDictionary(this);\n            this._copyTrailer(newXref);\n            this._writeDictionary(newXref, buffer, this._newLine);\n            this._writeString(\"startxref\" + this._newLine + newStartXref + this._newLine + \"%%EOF\" + this._newLine, buffer);\n        }\n        var array = new Uint8Array(this._stream.length + buffer.length);\n        array.set(this._stream.bytes);\n        array.set(buffer, this._stream.length);\n        return array;\n    };\n    _PdfCrossReference.prototype._copyTrailer = function (newXref) {\n        newXref.set('Size', this._nextReferenceNumber);\n        newXref.set('Prev', this._prevStartXref);\n        var root = this._trailer.getRaw('Root'); // eslint-disable-line\n        if (typeof root !== 'undefined' && root !== null) {\n            newXref.set('Root', root);\n        }\n        var info = this._trailer.getRaw('Info'); // eslint-disable-line\n        if (typeof info !== 'undefined' && info !== null) {\n            newXref.set('Info', info);\n        }\n        var encrypt = this._trailer.getRaw('Encrypt'); // eslint-disable-line\n        if (typeof encrypt !== 'undefined' && encrypt !== null) {\n            newXref.set('Encrypt', encrypt);\n        }\n    };\n    _PdfCrossReference.prototype._computeMessageDigest = function (size) {\n        var _this = this;\n        var time = Math.floor(Date.now() / 1000);\n        var buffer = [time.toString(), '', size.toString()];\n        var info = this._trailer.getRaw('Info');\n        var crossReferenceInfo = new _PdfDictionary();\n        if (info && info instanceof _PdfDictionary) {\n            info.forEach(function (key, value) {\n                if (value && typeof value === 'string') {\n                    crossReferenceInfo.set(key, _stringToPdfString(value));\n                }\n            });\n        }\n        crossReferenceInfo.forEach(function (key, value) {\n            buffer.push(value);\n        });\n        var array = [];\n        buffer.forEach(function (str) {\n            _this._writeString(str, array);\n        });\n        return _bytesToString((new _MD5().hash(new Uint8Array(array))));\n    };\n    _PdfCrossReference.prototype._getNextReference = function () {\n        var reference = new _PdfReference(this._nextReferenceNumber++, 0);\n        reference._isNew = true;\n        return reference;\n    };\n    _PdfCrossReference.prototype._writeObject = function (obj, buffer, reference, transform, isCrossReference) {\n        if (reference && reference instanceof _PdfReference) {\n            this._writeString(reference.objectNumber + \" \" + reference.generationNumber + \" obj\" + this._newLine, buffer);\n        }\n        if (obj instanceof _PdfDictionary) {\n            this._writeDictionary(obj, buffer, this._newLine, transform, isCrossReference);\n        }\n        else if (obj instanceof _PdfBaseStream) {\n            this._writeStream(obj, buffer, transform, isCrossReference);\n        }\n        if (reference && reference instanceof _PdfReference) {\n            this._writeString(\"endobj\" + this._newLine, buffer);\n        }\n    };\n    _PdfCrossReference.prototype._writeDictionary = function (dictionary, buffer, spaceChar, transform, isCrossReference) {\n        var _this = this;\n        if (dictionary._currentObj) {\n            dictionary._currentObj._beginSave();\n        }\n        if (dictionary._isFont) {\n            this._writeFontDictionary(dictionary);\n        }\n        this._writeString(\"<<\" + spaceChar, buffer);\n        dictionary.forEach(function (key, value) {\n            _this._writeString(\"/\" + _escapePdfName(key) + \" \", buffer);\n            _this._writeValue(value, buffer, transform, isCrossReference);\n            _this._writeString(spaceChar, buffer);\n        });\n        this._writeString(\">>\" + this._newLine, buffer);\n    };\n    _PdfCrossReference.prototype._writeFontDictionary = function (dictionary) {\n        if (dictionary.has('DescendantFonts')) {\n            var fonts = dictionary.get('DescendantFonts'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('DescendantFonts', [reference]);\n        }\n        if (dictionary.has('ToUnicode')) {\n            var fonts = dictionary.get('ToUnicode'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('ToUnicode', reference);\n        }\n        if (dictionary.has('FontFile2')) {\n            var fonts = dictionary.get('FontFile2'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('FontFile2', reference);\n        }\n        if (dictionary.has('FontDescriptor')) {\n            var fonts = dictionary.get('FontDescriptor'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('FontDescriptor', reference);\n        }\n    };\n    _PdfCrossReference.prototype._writeStream = function (stream, buffer, transform, isCrossReference) {\n        var streamBuffer = [];\n        var value = stream.getString();\n        if (!isCrossReference) {\n            var byteArray = [];\n            for (var i = 0; i < value.length; i++) {\n                byteArray.push(value.charCodeAt(i));\n            }\n            if (stream._isCompress) {\n                var dataArray = new Uint8Array(byteArray);\n                var sw = new CompressedStreamWriter();\n                sw.write(dataArray, 0, dataArray.length);\n                sw.close();\n                value = sw.getCompressedString;\n                stream.dictionary.update('Filter', _PdfName.get('FlateDecode'));\n            }\n            if (transform) {\n                value = transform.encryptString(value);\n            }\n        }\n        this._writeString(value, streamBuffer);\n        stream.dictionary.update('Length', streamBuffer.length);\n        this._writeDictionary(stream.dictionary, buffer, this._newLine, transform, isCrossReference);\n        this._writeString(\"stream\" + this._newLine, buffer);\n        this._writeBytes(streamBuffer, buffer);\n        this._writeString(this._newLine + \"endstream\" + this._newLine, buffer);\n    };\n    _PdfCrossReference.prototype._writeValue = function (value, buffer, transform, isCrossReference) {\n        if (value instanceof _PdfName) {\n            this._writeString(\"/\" + value.name, buffer);\n        }\n        else if (value instanceof _PdfReference) {\n            this._writeString(value.toString() + \" R\", buffer);\n        }\n        else if (Array.isArray(value)) {\n            this._writeString('[', buffer);\n            var first = true;\n            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                var val = value_1[_i];\n                if (!first) {\n                    this._writeString(' ', buffer);\n                }\n                else {\n                    first = false;\n                }\n                this._writeValue(val, buffer, transform, isCrossReference);\n            }\n            this._writeString(']', buffer);\n        }\n        else if (typeof value === 'string') {\n            if (!isCrossReference && transform) {\n                value = transform.encryptString(value);\n            }\n            this._writeString(\"(\" + this._escapeString(value) + \")\", buffer);\n        }\n        else if (typeof value === 'number') {\n            this._writeString(_numberToString(value), buffer);\n        }\n        else if (typeof value === 'boolean') {\n            this._writeString(value.toString(), buffer);\n        }\n        else if (value instanceof _PdfDictionary) {\n            this._writeDictionary(value, buffer, this._newLine, transform, isCrossReference);\n        }\n        else if (value instanceof _PdfBaseStream) {\n            this._writeStream(value, buffer, transform, isCrossReference);\n        }\n        else if (value === null) {\n            this._writeString('null', buffer);\n        }\n    };\n    _PdfCrossReference.prototype._writeString = function (value, buffer) {\n        for (var i = 0; i < value.length; i++) {\n            buffer.push(value.charCodeAt(i) & 0xff);\n        }\n    };\n    _PdfCrossReference.prototype._writeBytes = function (data, buffer) {\n        for (var i = 0; i < data.length; i++) {\n            buffer.push(data[i]); // eslint-disable-line\n        }\n    };\n    _PdfCrossReference.prototype._writeLong = function (value, count, buffer) {\n        for (var i = count - 1; i >= 0; --i) {\n            buffer.push(value >> (i << 3) & 0xff);\n        }\n    };\n    _PdfCrossReference.prototype._escapeString = function (value) {\n        return value.replace(/([()\\\\\\n\\r])/g, function (substring) {\n            if (substring === '\\n') {\n                return '\\\\n';\n            }\n            else if (substring === '\\r') {\n                return '\\\\r';\n            }\n            return \"\\\\\" + substring;\n        });\n    };\n    _PdfCrossReference.prototype._destroy = function () {\n        this._entries = undefined;\n        this._pendingRefs.clear();\n        this._pendingRefs = undefined;\n        this._cacheMap.clear();\n        this._pendingRefs = undefined;\n        this._root = undefined;\n        this._startXRefQueue = [];\n        this._startXRefQueue = undefined;\n        this._stream = undefined;\n        this._streamState = undefined;\n        this._tableState = undefined;\n        this._topDictionary = undefined;\n        this._trailer = undefined;\n        this._version = undefined;\n        this._crossReferencePosition = undefined;\n    };\n    return _PdfCrossReference;\n}());\nexport { _PdfCrossReference };\nvar _PdfObjectInformation = /** @class */ (function () {\n    function _PdfObjectInformation() {\n    }\n    return _PdfObjectInformation;\n}());\nvar _PdfCrossTableState = /** @class */ (function () {\n    function _PdfCrossTableState() {\n    }\n    return _PdfCrossTableState;\n}());\nvar _PdfStreamState = /** @class */ (function () {\n    function _PdfStreamState() {\n    }\n    return _PdfStreamState;\n}());\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}