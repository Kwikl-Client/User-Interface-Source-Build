{"ast":null,"code":"import require$$0, { memo, Children, useMemo, useRef, useCallback, useEffect, useState } from \"react\";\nimport mergeRefs from \"react-merge-refs\";\nimport useResizeObserver from \"use-resize-observer\";\nimport classNames from \"classnames\";\nconst getTurn = selected => {\n  let turn = selected % 1;\n  if (turn >= 0.5) {\n    turn -= 1;\n  }\n  return turn;\n};\nconst container$1 = \"_container_1v3jh_1\";\nvar classes$1 = {\n  container: container$1\n};\nvar jsxRuntime = {\n  exports: {}\n};\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f = require$$0,\n  k = Symbol.for(\"react.element\"),\n  l = Symbol.for(\"react.fragment\"),\n  m = Object.prototype.hasOwnProperty,\n  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,\n  p = {\n    key: true,\n    ref: true,\n    __self: true,\n    __source: true\n  };\nfunction q(c, a, g) {\n  var b,\n    d = {},\n    e = null,\n    h = null;\n  g !== void 0 && (e = \"\" + g);\n  a.key !== void 0 && (e = \"\" + a.key);\n  a.ref !== void 0 && (h = a.ref);\n  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n  if (c && c.defaultProps) for (b in a = c.defaultProps, a) d[b] === void 0 && (d[b] = a[b]);\n  return {\n    $$typeof: k,\n    type: c,\n    key: e,\n    ref: h,\n    props: d,\n    _owner: n.current\n  };\n}\nreactJsxRuntime_production_min.Fragment = l;\nreactJsxRuntime_production_min.jsx = q;\nreactJsxRuntime_production_min.jsxs = q;\n{\n  jsxRuntime.exports = reactJsxRuntime_production_min;\n}\nconst jsx = jsxRuntime.exports.jsx;\nconst jsxs = jsxRuntime.exports.jsxs;\nconst Fragment = jsxRuntime.exports.Fragment;\nconst defaultShadowBackground = \"rgb(0, 0, 0, 0.25)\";\nconst getFlippingPagesShadow = function () {\n  let background = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultShadowBackground;\n  const _FlippingPagesShadow = props => {\n    const {\n      selected,\n      willChange\n    } = props;\n    const turn = getTurn(selected);\n    return /* @__PURE__ */jsx(\"div\", {\n      className: classes$1.container,\n      style: {\n        background,\n        opacity: Math.abs(turn) * 2,\n        willChange: willChange ? \"opacity\" : void 0\n      }\n    });\n  };\n  return memo(_FlippingPagesShadow);\n};\nconst getTransform = (direction, turn) => {\n  switch (direction) {\n    case \"bottom-to-top\":\n      return \"rotateX(\".concat(turn * 180, \"deg)\");\n    case \"top-to-bottom\":\n      return \"rotateX(\".concat(turn * -180, \"deg)\");\n    case \"left-to-right\":\n      return \"rotateY(\".concat(turn * 180, \"deg)\");\n    case \"right-to-left\":\n      return \"rotateY(\".concat(turn * -180, \"deg)\");\n  }\n};\nconst container = \"_container_1veud_1\";\nconst fullPage = \"_fullPage_1veud_7\";\nconst prevPage = \"_prevPage_1veud_8\";\nconst nextPage = \"_nextPage_1veud_9\";\nconst shadow = \"_shadow_1veud_97\";\nvar classes = {\n  container,\n  fullPage,\n  prevPage,\n  nextPage,\n  \"bottom-to-top\": \"_bottom-to-top_1veud_13\",\n  \"top-to-bottom\": \"_top-to-bottom_1veud_13\",\n  \"left-to-right\": \"_left-to-right_1veud_17\",\n  \"right-to-left\": \"_right-to-left_1veud_17\",\n  shadow\n};\nconst _FlippingPagesCore = props => {\n  const {\n    containerProps,\n    containerRef,\n    direction,\n    selected,\n    shadowBackground\n  } = props;\n  const children = Children.toArray(props.children);\n  const ShadowComponent = useMemo(() => props.shadowComponent ? props.shadowComponent : getFlippingPagesShadow(shadowBackground), [shadowBackground, props.shadowComponent]);\n  const turn = getTurn(selected);\n  const willChange = !!props.willChange;\n  return /* @__PURE__ */jsxs(\"div\", {\n    ...containerProps,\n    ref: containerRef,\n    className: classNames(classes.container, containerProps === null || containerProps === void 0 ? void 0 : containerProps.className),\n    children: [/* @__PURE__ */jsx(\"div\", {\n      className: classNames({\n        [classes.fullPage]: turn === 0,\n        [classes.prevPage]: turn > 0,\n        [classes.nextPage]: turn < 0\n      }, classes[direction]),\n      children: /* @__PURE__ */jsx(\"div\", {\n        children: children[Math.round(selected)]\n      })\n    }), turn !== 0 && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        children: /* @__PURE__ */jsx(\"div\", {\n          children: children[turn > 0 ? Math.ceil(selected) : Math.floor(selected)]\n        })\n      }), /* @__PURE__ */jsxs(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        style: {\n          transform: getTransform(direction, turn),\n          willChange: willChange ? \"transform\" : void 0\n        },\n        children: [/* @__PURE__ */jsx(\"div\", {\n          children: children[Math.round(selected)]\n        }), /* @__PURE__ */jsx(\"div\", {\n          className: classes.shadow,\n          children: /* @__PURE__ */jsx(ShadowComponent, {\n            selected,\n            willChange\n          })\n        })]\n      })]\n    })]\n  });\n};\nconst FlippingPagesCore = memo(_FlippingPagesCore);\nconst defaultPerspectiveMultiplier = 2;\nconst _FlippingPagesWithPerspective = props => {\n  const {\n    direction,\n    perspectiveMultiplier = defaultPerspectiveMultiplier\n  } = props;\n  const {\n    ref,\n    height,\n    width\n  } = useResizeObserver();\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [ref, props.containerRef]);\n  const perspective = useMemo(() => {\n    switch (direction) {\n      case \"bottom-to-top\":\n      case \"top-to-bottom\":\n        if (!height) {\n          return;\n        }\n        return height * perspectiveMultiplier;\n      case \"left-to-right\":\n      case \"right-to-left\":\n        if (!width) {\n          return;\n        }\n        return width * perspectiveMultiplier;\n    }\n  }, [direction, perspectiveMultiplier, height, width]);\n  const containerProps = useMemo(() => {\n    var _props$containerProps;\n    return {\n      ...props.containerProps,\n      style: {\n        perspective,\n        ...((_props$containerProps = props.containerProps) === null || _props$containerProps === void 0 ? void 0 : _props$containerProps.style)\n      }\n    };\n  }, [props.containerProps, perspective]);\n  return /* @__PURE__ */jsx(FlippingPagesCore, {\n    ...props,\n    containerProps,\n    containerRef\n  });\n};\nconst FlippingPagesWithPerspective = memo(_FlippingPagesWithPerspective);\nconst useAnimation = options => {\n  const {\n    callback,\n    onEnd,\n    onStart\n  } = options;\n  const rafIdRef = useRef();\n  const startTimeRef = useRef();\n  const update = useCallback(timestamp => {\n    if (!startTimeRef.current) {\n      startTimeRef.current = timestamp;\n      rafIdRef.current = requestAnimationFrame(update);\n      return;\n    }\n    const timeElapsed = timestamp - startTimeRef.current;\n    const end = callback(timeElapsed);\n    if (end) {\n      rafIdRef.current = void 0;\n      onEnd();\n    } else {\n      rafIdRef.current = requestAnimationFrame(update);\n    }\n  }, [callback, onEnd]);\n  const start = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n    } else {\n      onStart();\n    }\n    startTimeRef.current = void 0;\n    rafIdRef.current = requestAnimationFrame(update);\n  }, [onStart, update]);\n  const stop = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n      rafIdRef.current = void 0;\n      onEnd();\n    }\n  }, [onEnd]);\n  useEffect(() => {\n    return () => {\n      if (rafIdRef.current) {\n        cancelAnimationFrame(rafIdRef.current);\n      }\n    };\n  }, []);\n  return {\n    start,\n    stop\n  };\n};\nconst defaultAnimationDuration = 400;\nconst _FlippingPagesWithAnimation = props => {\n  const {\n    animationDuration = defaultAnimationDuration,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn\n  } = props;\n  const [animationRunning, setAnimationRunning] = useState(false);\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return animationRunning ? true : void 0;\n  }, [props.willChange, animationRunning]);\n  const startSelectedRef = useRef(0);\n  const [selected, setSelected] = useState(props.selected);\n  const onStart = useCallback(() => {\n    setAnimationRunning(true);\n    onAnimationStart === null || onAnimationStart === void 0 || onAnimationStart();\n  }, [onAnimationStart]);\n  const onEnd = useCallback(() => {\n    setAnimationRunning(false);\n    onAnimationEnd === null || onAnimationEnd === void 0 || onAnimationEnd();\n  }, [onAnimationEnd]);\n  const updateAnimation = useCallback(timeElapsed => {\n    const maxSelectedChange = props.selected - startSelectedRef.current;\n    const selectedChange = Math.sign(maxSelectedChange) * timeElapsed / animationDuration;\n    if (Math.abs(selectedChange) >= Math.abs(maxSelectedChange)) {\n      setSelected(props.selected);\n      return true;\n    }\n    const newSelected = startSelectedRef.current + selectedChange;\n    setSelected(newSelected);\n    onAnimationTurn === null || onAnimationTurn === void 0 || onAnimationTurn(newSelected);\n    return false;\n  }, [animationDuration, onAnimationTurn, props.selected]);\n  const {\n    start,\n    stop\n  } = useAnimation({\n    callback: updateAnimation,\n    onEnd,\n    onStart\n  });\n  useEffect(() => {\n    if (selected === props.selected) {\n      stop();\n      return;\n    }\n    if (!animationDuration) {\n      stop();\n      setSelected(props.selected);\n      return;\n    }\n    startSelectedRef.current = selected;\n    start();\n  }, [animationDuration, props.selected]);\n  return /* @__PURE__ */jsx(FlippingPagesWithPerspective, {\n    ...props,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithAnimation = memo(_FlippingPagesWithAnimation);\nconst useMergeEvents = function () {\n  for (var _len = arguments.length, eventHandlers = new Array(_len), _key = 0; _key < _len; _key++) {\n    eventHandlers[_key] = arguments[_key];\n  }\n  return useCallback(event => {\n    for (const eventHandler of eventHandlers) {\n      eventHandler === null || eventHandler === void 0 || eventHandler(event);\n    }\n  }, eventHandlers);\n};\nconst useMergePointerEvents = function () {\n  for (var _len2 = arguments.length, eventsEmitters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    eventsEmitters[_key2] = arguments[_key2];\n  }\n  const onPointerCancel = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter === null || eventsEmitter === void 0 ? void 0 : eventsEmitter.onPointerCancel));\n  const onPointerDown = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter === null || eventsEmitter === void 0 ? void 0 : eventsEmitter.onPointerDown));\n  const onPointerMove = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter === null || eventsEmitter === void 0 ? void 0 : eventsEmitter.onPointerMove));\n  const onPointerUp = useMergeEvents(...eventsEmitters.map(eventsEmitter => eventsEmitter === null || eventsEmitter === void 0 ? void 0 : eventsEmitter.onPointerUp));\n  return {\n    onPointerCancel,\n    onPointerDown,\n    onPointerMove,\n    onPointerUp\n  };\n};\nconst usePointerEvents = options => {\n  const {\n    onDown,\n    onMove,\n    onUp\n  } = options;\n  const [pointerId, setPointerId] = useState();\n  const pointerDown = pointerId !== void 0;\n  const startXRef = useRef(0);\n  const startYRef = useRef(0);\n  const lastTimeStampRef = useRef(0);\n  const lastXRef = useRef(0);\n  const lastYRef = useRef(0);\n  const currTimeStampRef = useRef(0);\n  const currXRef = useRef(0);\n  const currYRef = useRef(0);\n  const onPointerDown = useCallback(event => {\n    if (!onDown(event)) {\n      return;\n    }\n    event.currentTarget.setPointerCapture(event.pointerId);\n    setPointerId(event.pointerId);\n    startXRef.current = event.clientX;\n    startYRef.current = event.clientY;\n    lastTimeStampRef.current = 0;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n  }, [onDown]);\n  const onPointerMove = useCallback(event => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    lastTimeStampRef.current = currTimeStampRef.current;\n    lastXRef.current = currXRef.current;\n    lastYRef.current = currYRef.current;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onMove({\n      diffX,\n      diffY\n    });\n  }, [onMove, pointerId]);\n  const onPointerUp = useCallback(event => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    let speedX;\n    let speedY;\n    if (lastTimeStampRef.current) {\n      const timeDiff = event.timeStamp - lastTimeStampRef.current;\n      speedX = (event.clientX - lastXRef.current) / timeDiff;\n      speedY = (event.clientY - lastYRef.current) / timeDiff;\n    } else {\n      speedX = 0;\n      speedY = 0;\n    }\n    onUp({\n      diffX,\n      diffY,\n      speedX,\n      speedY\n    });\n  }, [onUp, pointerId]);\n  const onPointerCancel = useCallback(event => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onUp({\n      diffX,\n      diffY,\n      speedX: 0,\n      speedY: 0\n    });\n  }, [onUp, pointerId]);\n  const cancelPointer = useCallback(() => {\n    setPointerId(void 0);\n  }, []);\n  return {\n    cancelPointer,\n    onPointerCancel,\n    onPointerDown,\n    onPointerMove,\n    onPointerUp,\n    pointerDown\n  };\n};\nconst getCurrSelected = options => {\n  const {\n    childrenLength,\n    diffX,\n    diffY,\n    direction,\n    onOverSwipe,\n    startSelected,\n    swipeLength\n  } = options;\n  let diff;\n  switch (direction) {\n    case \"bottom-to-top\":\n      diff = -diffY;\n      break;\n    case \"top-to-bottom\":\n      diff = diffY;\n      break;\n    case \"left-to-right\":\n      diff = diffX;\n      break;\n    case \"right-to-left\":\n      diff = -diffX;\n      break;\n  }\n  let selected = startSelected + diff / swipeLength;\n  selected = Math.max(selected, Math.ceil(startSelected) - 1);\n  selected = Math.min(selected, Math.floor(startSelected) + 1);\n  if (selected < 0) {\n    const overSwipe = Math.min(-selected, 1);\n    selected = -onOverSwipe(overSwipe);\n  } else if (selected > childrenLength - 1) {\n    const overSwipe = Math.min(selected - childrenLength + 1, 1);\n    selected = childrenLength - 1 + onOverSwipe(overSwipe);\n  }\n  return selected;\n};\nconst getNextSelected = options => {\n  const {\n    childrenLength,\n    direction,\n    speedX,\n    speedY,\n    startSelected,\n    swipeSpeed\n  } = options;\n  const selected = getCurrSelected(options);\n  let speed;\n  switch (direction) {\n    case \"bottom-to-top\":\n      speed = -speedY;\n      break;\n    case \"top-to-bottom\":\n      speed = speedY;\n      break;\n    case \"left-to-right\":\n      speed = speedX;\n      break;\n    case \"right-to-left\":\n      speed = -speedX;\n      break;\n  }\n  let newSelected;\n  if (Math.abs(speed) < swipeSpeed) {\n    newSelected = Math.round(selected);\n  } else if (speed > swipeSpeed) {\n    newSelected = Math.floor(selected) + 1;\n  } else {\n    newSelected = Math.ceil(selected) - 1;\n  }\n  newSelected = Math.max(newSelected, Math.ceil(startSelected) - 1, 0);\n  newSelected = Math.min(newSelected, Math.floor(startSelected) + 1, childrenLength - 1);\n  return newSelected;\n};\nconst defaultSwipeLength = 400;\nconst defaultOnOverSwipe = overSwipe => overSwipe / 4;\nconst defaultOnSwipeStart = event => event.isPrimary;\nconst defaultSwipeSpeed = 0.1;\nconst _FlippingPagesWithPointerControls = props => {\n  const {\n    children,\n    direction,\n    disableSwipe,\n    noSwipeClass,\n    onAnimationEnd: _onAnimationEnd,\n    onAnimationStart: _onAnimationStart,\n    onAnimationTurn: _onAnimationTurn,\n    onOverSwipe = defaultOnOverSwipe,\n    onSwipeEnd,\n    onSwipeStart = defaultOnSwipeStart,\n    onSwipeTurn,\n    swipeLength = defaultSwipeLength,\n    swipeSpeed = defaultSwipeSpeed\n  } = props;\n  const ref = useRef(null);\n  const childrenLength = Children.count(children);\n  const animationRunningRef = useRef(false);\n  const startSelectedRef = useRef(props.selected);\n  const [pointerSelected, setPointerSelected] = useState(props.selected);\n  const onAnimationStart = useCallback(() => {\n    animationRunningRef.current = true;\n    _onAnimationStart === null || _onAnimationStart === void 0 || _onAnimationStart();\n  }, [_onAnimationStart]);\n  const onAnimationTurn = useCallback(selected2 => {\n    startSelectedRef.current = selected2;\n    _onAnimationTurn === null || _onAnimationTurn === void 0 || _onAnimationTurn(selected2);\n  }, [_onAnimationTurn]);\n  const onAnimationEnd = useCallback(() => {\n    animationRunningRef.current = false;\n    _onAnimationEnd === null || _onAnimationEnd === void 0 || _onAnimationEnd();\n  }, [_onAnimationEnd]);\n  const onDown = useCallback(event => {\n    if (disableSwipe) {\n      return false;\n    }\n    if (noSwipeClass) {\n      if (event.target instanceof Element) {\n        let target = event.target;\n        while (target && target !== ref.current) {\n          if (target.classList.contains(noSwipeClass)) {\n            return false;\n          }\n          target = target.parentElement;\n        }\n      }\n    }\n    if (!onSwipeStart(event)) {\n      return false;\n    }\n    if (!animationRunningRef.current) {\n      startSelectedRef.current = props.selected;\n    }\n    setPointerSelected(startSelectedRef.current);\n    return true;\n  }, [disableSwipe, noSwipeClass, onSwipeStart, props.selected]);\n  const onMove = useCallback(options => {\n    const {\n      diffX,\n      diffY\n    } = options;\n    const selected2 = getCurrSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      startSelected: startSelectedRef.current,\n      swipeLength\n    });\n    setPointerSelected(selected2);\n    onSwipeTurn === null || onSwipeTurn === void 0 || onSwipeTurn(selected2);\n  }, [childrenLength, direction, onOverSwipe, onSwipeTurn, swipeLength]);\n  const onUp = useCallback(options => {\n    const {\n      diffX,\n      diffY,\n      speedX,\n      speedY\n    } = options;\n    const nextSelected = getNextSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      speedX,\n      speedY,\n      startSelected: startSelectedRef.current,\n      swipeLength,\n      swipeSpeed\n    });\n    onSwipeEnd === null || onSwipeEnd === void 0 || onSwipeEnd(nextSelected);\n  }, [childrenLength, direction, onOverSwipe, onSwipeEnd, swipeLength, swipeSpeed]);\n  const {\n    cancelPointer,\n    pointerDown,\n    ..._pointerEventListeners\n  } = usePointerEvents({\n    onDown,\n    onMove,\n    onUp\n  });\n  useEffect(() => {\n    if (disableSwipe) {\n      cancelPointer();\n    }\n  }, [cancelPointer, disableSwipe]);\n  const animationDuration = pointerDown ? 0 : props.animationDuration;\n  const selected = pointerDown ? pointerSelected : props.selected;\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return pointerDown ? true : void 0;\n  }, [pointerDown, props.willChange]);\n  const pointerEventListeners = useMergePointerEvents(_pointerEventListeners, props.containerProps);\n  const containerProps = useMemo(() => ({\n    ...props.containerProps,\n    ...pointerEventListeners\n  }), [pointerEventListeners, props.containerProps]);\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [props.containerRef]);\n  return /* @__PURE__ */jsx(FlippingPagesWithAnimation, {\n    ...props,\n    animationDuration,\n    containerProps,\n    containerRef,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithPointerControls = memo(_FlippingPagesWithPointerControls);\nconst FlippingPages = FlippingPagesWithPointerControls;\nFlippingPages.displayName = \"FlippingPages\";\nexport { FlippingPages };","map":{"version":3,"names":["require$$0","memo","Children","useMemo","useRef","useCallback","useEffect","useState","mergeRefs","useResizeObserver","classNames","getTurn","selected","turn","container$1","classes$1","container","jsxRuntime","exports","reactJsxRuntime_production_min","f","k","Symbol","for","l","m","Object","prototype","hasOwnProperty","n","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","p","key","ref","__self","__source","q","c","a","g","b","d","e","h","call","defaultProps","$$typeof","type","props","_owner","current","Fragment","jsx","jsxs","defaultShadowBackground","getFlippingPagesShadow","background","arguments","length","undefined","_FlippingPagesShadow","willChange","className","style","opacity","Math","abs","getTransform","direction","concat","fullPage","prevPage","nextPage","shadow","classes","_FlippingPagesCore","containerProps","containerRef","shadowBackground","children","toArray","ShadowComponent","shadowComponent","round","ceil","floor","transform","FlippingPagesCore","defaultPerspectiveMultiplier","_FlippingPagesWithPerspective","perspectiveMultiplier","height","width","refs","push","perspective","_props$containerProps","FlippingPagesWithPerspective","useAnimation","options","callback","onEnd","onStart","rafIdRef","startTimeRef","update","timestamp","requestAnimationFrame","timeElapsed","end","start","cancelAnimationFrame","stop","defaultAnimationDuration","_FlippingPagesWithAnimation","animationDuration","onAnimationEnd","onAnimationStart","onAnimationTurn","animationRunning","setAnimationRunning","startSelectedRef","setSelected","updateAnimation","maxSelectedChange","selectedChange","sign","newSelected","FlippingPagesWithAnimation","useMergeEvents","_len","eventHandlers","Array","_key","event","eventHandler","useMergePointerEvents","_len2","eventsEmitters","_key2","onPointerCancel","map","eventsEmitter","onPointerDown","onPointerMove","onPointerUp","usePointerEvents","onDown","onMove","onUp","pointerId","setPointerId","pointerDown","startXRef","startYRef","lastTimeStampRef","lastXRef","lastYRef","currTimeStampRef","currXRef","currYRef","currentTarget","setPointerCapture","clientX","clientY","timeStamp","diffX","diffY","speedX","speedY","timeDiff","cancelPointer","getCurrSelected","childrenLength","onOverSwipe","startSelected","swipeLength","diff","max","min","overSwipe","getNextSelected","swipeSpeed","speed","defaultSwipeLength","defaultOnOverSwipe","defaultOnSwipeStart","isPrimary","defaultSwipeSpeed","_FlippingPagesWithPointerControls","disableSwipe","noSwipeClass","_onAnimationEnd","_onAnimationStart","_onAnimationTurn","onSwipeEnd","onSwipeStart","onSwipeTurn","count","animationRunningRef","pointerSelected","setPointerSelected","selected2","target","Element","classList","contains","parentElement","nextSelected","_pointerEventListeners","pointerEventListeners","FlippingPagesWithPointerControls","FlippingPages","displayName"],"sources":["/Users/saleem/Desktop/KClient/Web App/Ver_3.6/User Interface/website_Source files/node_modules/flipping-pages/dist/flipping-pages.es.js"],"sourcesContent":["import require$$0, { memo, Children, useMemo, useRef, useCallback, useEffect, useState } from \"react\";\nimport mergeRefs from \"react-merge-refs\";\nimport useResizeObserver from \"use-resize-observer\";\nimport classNames from \"classnames\";\nconst getTurn = (selected) => {\n  let turn = selected % 1;\n  if (turn >= 0.5) {\n    turn -= 1;\n  }\n  return turn;\n};\nconst container$1 = \"_container_1v3jh_1\";\nvar classes$1 = {\n  container: container$1\n};\nvar jsxRuntime = { exports: {} };\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f = require$$0, k = Symbol.for(\"react.element\"), l = Symbol.for(\"react.fragment\"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };\nfunction q(c, a, g) {\n  var b, d = {}, e = null, h = null;\n  g !== void 0 && (e = \"\" + g);\n  a.key !== void 0 && (e = \"\" + a.key);\n  a.ref !== void 0 && (h = a.ref);\n  for (b in a)\n    m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n  if (c && c.defaultProps)\n    for (b in a = c.defaultProps, a)\n      d[b] === void 0 && (d[b] = a[b]);\n  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };\n}\nreactJsxRuntime_production_min.Fragment = l;\nreactJsxRuntime_production_min.jsx = q;\nreactJsxRuntime_production_min.jsxs = q;\n{\n  jsxRuntime.exports = reactJsxRuntime_production_min;\n}\nconst jsx = jsxRuntime.exports.jsx;\nconst jsxs = jsxRuntime.exports.jsxs;\nconst Fragment = jsxRuntime.exports.Fragment;\nconst defaultShadowBackground = \"rgb(0, 0, 0, 0.25)\";\nconst getFlippingPagesShadow = (background = defaultShadowBackground) => {\n  const _FlippingPagesShadow = (props) => {\n    const {\n      selected,\n      willChange\n    } = props;\n    const turn = getTurn(selected);\n    return /* @__PURE__ */ jsx(\"div\", {\n      className: classes$1.container,\n      style: {\n        background,\n        opacity: Math.abs(turn) * 2,\n        willChange: willChange ? \"opacity\" : void 0\n      }\n    });\n  };\n  return memo(_FlippingPagesShadow);\n};\nconst getTransform = (direction, turn) => {\n  switch (direction) {\n    case \"bottom-to-top\":\n      return `rotateX(${turn * 180}deg)`;\n    case \"top-to-bottom\":\n      return `rotateX(${turn * -180}deg)`;\n    case \"left-to-right\":\n      return `rotateY(${turn * 180}deg)`;\n    case \"right-to-left\":\n      return `rotateY(${turn * -180}deg)`;\n  }\n};\nconst container = \"_container_1veud_1\";\nconst fullPage = \"_fullPage_1veud_7\";\nconst prevPage = \"_prevPage_1veud_8\";\nconst nextPage = \"_nextPage_1veud_9\";\nconst shadow = \"_shadow_1veud_97\";\nvar classes = {\n  container,\n  fullPage,\n  prevPage,\n  nextPage,\n  \"bottom-to-top\": \"_bottom-to-top_1veud_13\",\n  \"top-to-bottom\": \"_top-to-bottom_1veud_13\",\n  \"left-to-right\": \"_left-to-right_1veud_17\",\n  \"right-to-left\": \"_right-to-left_1veud_17\",\n  shadow\n};\nconst _FlippingPagesCore = (props) => {\n  const {\n    containerProps,\n    containerRef,\n    direction,\n    selected,\n    shadowBackground\n  } = props;\n  const children = Children.toArray(props.children);\n  const ShadowComponent = useMemo(() => props.shadowComponent ? props.shadowComponent : getFlippingPagesShadow(shadowBackground), [shadowBackground, props.shadowComponent]);\n  const turn = getTurn(selected);\n  const willChange = !!props.willChange;\n  return /* @__PURE__ */ jsxs(\"div\", {\n    ...containerProps,\n    ref: containerRef,\n    className: classNames(classes.container, containerProps?.className),\n    children: [/* @__PURE__ */ jsx(\"div\", {\n      className: classNames({\n        [classes.fullPage]: turn === 0,\n        [classes.prevPage]: turn > 0,\n        [classes.nextPage]: turn < 0\n      }, classes[direction]),\n      children: /* @__PURE__ */ jsx(\"div\", {\n        children: children[Math.round(selected)]\n      })\n    }), turn !== 0 && /* @__PURE__ */ jsxs(Fragment, {\n      children: [/* @__PURE__ */ jsx(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        children: /* @__PURE__ */ jsx(\"div\", {\n          children: children[turn > 0 ? Math.ceil(selected) : Math.floor(selected)]\n        })\n      }), /* @__PURE__ */ jsxs(\"div\", {\n        className: classNames(turn > 0 ? classes.nextPage : classes.prevPage, classes[direction]),\n        style: {\n          transform: getTransform(direction, turn),\n          willChange: willChange ? \"transform\" : void 0\n        },\n        children: [/* @__PURE__ */ jsx(\"div\", {\n          children: children[Math.round(selected)]\n        }), /* @__PURE__ */ jsx(\"div\", {\n          className: classes.shadow,\n          children: /* @__PURE__ */ jsx(ShadowComponent, {\n            selected,\n            willChange\n          })\n        })]\n      })]\n    })]\n  });\n};\nconst FlippingPagesCore = memo(_FlippingPagesCore);\nconst defaultPerspectiveMultiplier = 2;\nconst _FlippingPagesWithPerspective = (props) => {\n  const {\n    direction,\n    perspectiveMultiplier = defaultPerspectiveMultiplier\n  } = props;\n  const {\n    ref,\n    height,\n    width\n  } = useResizeObserver();\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [ref, props.containerRef]);\n  const perspective = useMemo(() => {\n    switch (direction) {\n      case \"bottom-to-top\":\n      case \"top-to-bottom\":\n        if (!height) {\n          return;\n        }\n        return height * perspectiveMultiplier;\n      case \"left-to-right\":\n      case \"right-to-left\":\n        if (!width) {\n          return;\n        }\n        return width * perspectiveMultiplier;\n    }\n  }, [direction, perspectiveMultiplier, height, width]);\n  const containerProps = useMemo(() => ({\n    ...props.containerProps,\n    style: {\n      perspective,\n      ...props.containerProps?.style\n    }\n  }), [props.containerProps, perspective]);\n  return /* @__PURE__ */ jsx(FlippingPagesCore, {\n    ...props,\n    containerProps,\n    containerRef\n  });\n};\nconst FlippingPagesWithPerspective = memo(_FlippingPagesWithPerspective);\nconst useAnimation = (options) => {\n  const { callback, onEnd, onStart } = options;\n  const rafIdRef = useRef();\n  const startTimeRef = useRef();\n  const update = useCallback((timestamp) => {\n    if (!startTimeRef.current) {\n      startTimeRef.current = timestamp;\n      rafIdRef.current = requestAnimationFrame(update);\n      return;\n    }\n    const timeElapsed = timestamp - startTimeRef.current;\n    const end = callback(timeElapsed);\n    if (end) {\n      rafIdRef.current = void 0;\n      onEnd();\n    } else {\n      rafIdRef.current = requestAnimationFrame(update);\n    }\n  }, [callback, onEnd]);\n  const start = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n    } else {\n      onStart();\n    }\n    startTimeRef.current = void 0;\n    rafIdRef.current = requestAnimationFrame(update);\n  }, [onStart, update]);\n  const stop = useCallback(() => {\n    if (rafIdRef.current) {\n      cancelAnimationFrame(rafIdRef.current);\n      rafIdRef.current = void 0;\n      onEnd();\n    }\n  }, [onEnd]);\n  useEffect(() => {\n    return () => {\n      if (rafIdRef.current) {\n        cancelAnimationFrame(rafIdRef.current);\n      }\n    };\n  }, []);\n  return { start, stop };\n};\nconst defaultAnimationDuration = 400;\nconst _FlippingPagesWithAnimation = (props) => {\n  const {\n    animationDuration = defaultAnimationDuration,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn\n  } = props;\n  const [animationRunning, setAnimationRunning] = useState(false);\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return animationRunning ? true : void 0;\n  }, [props.willChange, animationRunning]);\n  const startSelectedRef = useRef(0);\n  const [selected, setSelected] = useState(props.selected);\n  const onStart = useCallback(() => {\n    setAnimationRunning(true);\n    onAnimationStart?.();\n  }, [onAnimationStart]);\n  const onEnd = useCallback(() => {\n    setAnimationRunning(false);\n    onAnimationEnd?.();\n  }, [onAnimationEnd]);\n  const updateAnimation = useCallback((timeElapsed) => {\n    const maxSelectedChange = props.selected - startSelectedRef.current;\n    const selectedChange = Math.sign(maxSelectedChange) * timeElapsed / animationDuration;\n    if (Math.abs(selectedChange) >= Math.abs(maxSelectedChange)) {\n      setSelected(props.selected);\n      return true;\n    }\n    const newSelected = startSelectedRef.current + selectedChange;\n    setSelected(newSelected);\n    onAnimationTurn?.(newSelected);\n    return false;\n  }, [animationDuration, onAnimationTurn, props.selected]);\n  const {\n    start,\n    stop\n  } = useAnimation({\n    callback: updateAnimation,\n    onEnd,\n    onStart\n  });\n  useEffect(() => {\n    if (selected === props.selected) {\n      stop();\n      return;\n    }\n    if (!animationDuration) {\n      stop();\n      setSelected(props.selected);\n      return;\n    }\n    startSelectedRef.current = selected;\n    start();\n  }, [animationDuration, props.selected]);\n  return /* @__PURE__ */ jsx(FlippingPagesWithPerspective, {\n    ...props,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithAnimation = memo(_FlippingPagesWithAnimation);\nconst useMergeEvents = (...eventHandlers) => useCallback((event) => {\n  for (const eventHandler of eventHandlers) {\n    eventHandler?.(event);\n  }\n}, eventHandlers);\nconst useMergePointerEvents = (...eventsEmitters) => {\n  const onPointerCancel = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerCancel));\n  const onPointerDown = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerDown));\n  const onPointerMove = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerMove));\n  const onPointerUp = useMergeEvents(...eventsEmitters.map((eventsEmitter) => eventsEmitter?.onPointerUp));\n  return { onPointerCancel, onPointerDown, onPointerMove, onPointerUp };\n};\nconst usePointerEvents = (options) => {\n  const { onDown, onMove, onUp } = options;\n  const [pointerId, setPointerId] = useState();\n  const pointerDown = pointerId !== void 0;\n  const startXRef = useRef(0);\n  const startYRef = useRef(0);\n  const lastTimeStampRef = useRef(0);\n  const lastXRef = useRef(0);\n  const lastYRef = useRef(0);\n  const currTimeStampRef = useRef(0);\n  const currXRef = useRef(0);\n  const currYRef = useRef(0);\n  const onPointerDown = useCallback((event) => {\n    if (!onDown(event)) {\n      return;\n    }\n    event.currentTarget.setPointerCapture(event.pointerId);\n    setPointerId(event.pointerId);\n    startXRef.current = event.clientX;\n    startYRef.current = event.clientY;\n    lastTimeStampRef.current = 0;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n  }, [onDown]);\n  const onPointerMove = useCallback((event) => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    lastTimeStampRef.current = currTimeStampRef.current;\n    lastXRef.current = currXRef.current;\n    lastYRef.current = currYRef.current;\n    currTimeStampRef.current = event.timeStamp;\n    currXRef.current = event.clientX;\n    currYRef.current = event.clientY;\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onMove({ diffX, diffY });\n  }, [onMove, pointerId]);\n  const onPointerUp = useCallback((event) => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    let speedX;\n    let speedY;\n    if (lastTimeStampRef.current) {\n      const timeDiff = event.timeStamp - lastTimeStampRef.current;\n      speedX = (event.clientX - lastXRef.current) / timeDiff;\n      speedY = (event.clientY - lastYRef.current) / timeDiff;\n    } else {\n      speedX = 0;\n      speedY = 0;\n    }\n    onUp({ diffX, diffY, speedX, speedY });\n  }, [onUp, pointerId]);\n  const onPointerCancel = useCallback((event) => {\n    if (event.pointerId !== pointerId) {\n      return;\n    }\n    setPointerId(void 0);\n    const diffX = event.clientX - startXRef.current;\n    const diffY = event.clientY - startYRef.current;\n    onUp({ diffX, diffY, speedX: 0, speedY: 0 });\n  }, [onUp, pointerId]);\n  const cancelPointer = useCallback(() => {\n    setPointerId(void 0);\n  }, []);\n  return {\n    cancelPointer,\n    onPointerCancel,\n    onPointerDown,\n    onPointerMove,\n    onPointerUp,\n    pointerDown\n  };\n};\nconst getCurrSelected = (options) => {\n  const { childrenLength, diffX, diffY, direction, onOverSwipe, startSelected, swipeLength } = options;\n  let diff;\n  switch (direction) {\n    case \"bottom-to-top\":\n      diff = -diffY;\n      break;\n    case \"top-to-bottom\":\n      diff = diffY;\n      break;\n    case \"left-to-right\":\n      diff = diffX;\n      break;\n    case \"right-to-left\":\n      diff = -diffX;\n      break;\n  }\n  let selected = startSelected + diff / swipeLength;\n  selected = Math.max(selected, Math.ceil(startSelected) - 1);\n  selected = Math.min(selected, Math.floor(startSelected) + 1);\n  if (selected < 0) {\n    const overSwipe = Math.min(-selected, 1);\n    selected = -onOverSwipe(overSwipe);\n  } else if (selected > childrenLength - 1) {\n    const overSwipe = Math.min(selected - childrenLength + 1, 1);\n    selected = childrenLength - 1 + onOverSwipe(overSwipe);\n  }\n  return selected;\n};\nconst getNextSelected = (options) => {\n  const { childrenLength, direction, speedX, speedY, startSelected, swipeSpeed } = options;\n  const selected = getCurrSelected(options);\n  let speed;\n  switch (direction) {\n    case \"bottom-to-top\":\n      speed = -speedY;\n      break;\n    case \"top-to-bottom\":\n      speed = speedY;\n      break;\n    case \"left-to-right\":\n      speed = speedX;\n      break;\n    case \"right-to-left\":\n      speed = -speedX;\n      break;\n  }\n  let newSelected;\n  if (Math.abs(speed) < swipeSpeed) {\n    newSelected = Math.round(selected);\n  } else if (speed > swipeSpeed) {\n    newSelected = Math.floor(selected) + 1;\n  } else {\n    newSelected = Math.ceil(selected) - 1;\n  }\n  newSelected = Math.max(newSelected, Math.ceil(startSelected) - 1, 0);\n  newSelected = Math.min(newSelected, Math.floor(startSelected) + 1, childrenLength - 1);\n  return newSelected;\n};\nconst defaultSwipeLength = 400;\nconst defaultOnOverSwipe = (overSwipe) => overSwipe / 4;\nconst defaultOnSwipeStart = (event) => event.isPrimary;\nconst defaultSwipeSpeed = 0.1;\nconst _FlippingPagesWithPointerControls = (props) => {\n  const {\n    children,\n    direction,\n    disableSwipe,\n    noSwipeClass,\n    onAnimationEnd: _onAnimationEnd,\n    onAnimationStart: _onAnimationStart,\n    onAnimationTurn: _onAnimationTurn,\n    onOverSwipe = defaultOnOverSwipe,\n    onSwipeEnd,\n    onSwipeStart = defaultOnSwipeStart,\n    onSwipeTurn,\n    swipeLength = defaultSwipeLength,\n    swipeSpeed = defaultSwipeSpeed\n  } = props;\n  const ref = useRef(null);\n  const childrenLength = Children.count(children);\n  const animationRunningRef = useRef(false);\n  const startSelectedRef = useRef(props.selected);\n  const [pointerSelected, setPointerSelected] = useState(props.selected);\n  const onAnimationStart = useCallback(() => {\n    animationRunningRef.current = true;\n    _onAnimationStart?.();\n  }, [_onAnimationStart]);\n  const onAnimationTurn = useCallback((selected2) => {\n    startSelectedRef.current = selected2;\n    _onAnimationTurn?.(selected2);\n  }, [_onAnimationTurn]);\n  const onAnimationEnd = useCallback(() => {\n    animationRunningRef.current = false;\n    _onAnimationEnd?.();\n  }, [_onAnimationEnd]);\n  const onDown = useCallback((event) => {\n    if (disableSwipe) {\n      return false;\n    }\n    if (noSwipeClass) {\n      if (event.target instanceof Element) {\n        let target = event.target;\n        while (target && target !== ref.current) {\n          if (target.classList.contains(noSwipeClass)) {\n            return false;\n          }\n          target = target.parentElement;\n        }\n      }\n    }\n    if (!onSwipeStart(event)) {\n      return false;\n    }\n    if (!animationRunningRef.current) {\n      startSelectedRef.current = props.selected;\n    }\n    setPointerSelected(startSelectedRef.current);\n    return true;\n  }, [disableSwipe, noSwipeClass, onSwipeStart, props.selected]);\n  const onMove = useCallback((options) => {\n    const {\n      diffX,\n      diffY\n    } = options;\n    const selected2 = getCurrSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      startSelected: startSelectedRef.current,\n      swipeLength\n    });\n    setPointerSelected(selected2);\n    onSwipeTurn?.(selected2);\n  }, [childrenLength, direction, onOverSwipe, onSwipeTurn, swipeLength]);\n  const onUp = useCallback((options) => {\n    const {\n      diffX,\n      diffY,\n      speedX,\n      speedY\n    } = options;\n    const nextSelected = getNextSelected({\n      childrenLength,\n      diffX,\n      diffY,\n      direction,\n      onOverSwipe,\n      speedX,\n      speedY,\n      startSelected: startSelectedRef.current,\n      swipeLength,\n      swipeSpeed\n    });\n    onSwipeEnd?.(nextSelected);\n  }, [childrenLength, direction, onOverSwipe, onSwipeEnd, swipeLength, swipeSpeed]);\n  const {\n    cancelPointer,\n    pointerDown,\n    ..._pointerEventListeners\n  } = usePointerEvents({\n    onDown,\n    onMove,\n    onUp\n  });\n  useEffect(() => {\n    if (disableSwipe) {\n      cancelPointer();\n    }\n  }, [cancelPointer, disableSwipe]);\n  const animationDuration = pointerDown ? 0 : props.animationDuration;\n  const selected = pointerDown ? pointerSelected : props.selected;\n  const willChange = useMemo(() => {\n    if (typeof props.willChange === \"boolean\") {\n      return props.willChange;\n    }\n    return pointerDown ? true : void 0;\n  }, [pointerDown, props.willChange]);\n  const pointerEventListeners = useMergePointerEvents(_pointerEventListeners, props.containerProps);\n  const containerProps = useMemo(() => ({\n    ...props.containerProps,\n    ...pointerEventListeners\n  }), [pointerEventListeners, props.containerProps]);\n  const containerRef = useMemo(() => {\n    const refs = [ref];\n    if (props.containerRef) {\n      refs.push(props.containerRef);\n    }\n    return mergeRefs(refs);\n  }, [props.containerRef]);\n  return /* @__PURE__ */ jsx(FlippingPagesWithAnimation, {\n    ...props,\n    animationDuration,\n    containerProps,\n    containerRef,\n    onAnimationEnd,\n    onAnimationStart,\n    onAnimationTurn,\n    selected,\n    willChange\n  });\n};\nconst FlippingPagesWithPointerControls = memo(_FlippingPagesWithPointerControls);\nconst FlippingPages = FlippingPagesWithPointerControls;\nFlippingPages.displayName = \"FlippingPages\";\nexport { FlippingPages };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}