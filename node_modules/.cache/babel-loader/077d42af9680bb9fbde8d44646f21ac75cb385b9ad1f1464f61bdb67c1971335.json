{"ast":null,"code":"import { _PdfCommand, _PdfName, _PdfDictionary, _isCommand, _PdfReference } from './pdf-primitives';\nimport { _isWhiteSpace, FormatError, ParserEndOfFileException } from './utils';\nimport { _PdfNullStream } from './base-stream';\nimport { PdfPredictorStream } from './predictor-stream';\nimport { _PdfFlateStream } from './flate-stream';\nvar maxCacheLength = 1000;\nvar maxNumberLength = 5552;\nvar endOfFile = 'EOF';\nvar specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nvar _PdfLexicalOperator = /** @class */function () {\n  function _PdfLexicalOperator(stream) {\n    this.stream = stream;\n    this.nextChar();\n    this.stringBuffer = [];\n    this._hexStringNumber = 0;\n    this.beginInlineImagePosition = -1;\n  }\n  _PdfLexicalOperator.prototype.nextChar = function () {\n    return this.currentChar = this.stream.getByte();\n  };\n  _PdfLexicalOperator.prototype.peekChar = function () {\n    return this.stream.peekByte();\n  };\n  _PdfLexicalOperator.prototype.getNumber = function () {\n    var ch = this.currentChar;\n    var eNotation = false;\n    var divideBy = 0;\n    var sign = 0;\n    if (ch === 0x2d) {\n      sign = -1;\n      ch = this.nextChar();\n      if (ch === 0x2d) {\n        ch = this.nextChar();\n      }\n    } else if (ch === 0x2b) {\n      sign = 1;\n      ch = this.nextChar();\n    }\n    if (ch === 0x0a || ch === 0x0d) {\n      do {\n        ch = this.nextChar();\n      } while (ch === 0x0a || ch === 0x0d);\n    }\n    if (ch === 0x2e) {\n      divideBy = 10;\n      ch = this.nextChar();\n    }\n    if (ch < 0x30 || ch > 0x39) {\n      if (_isWhiteSpace(ch) || ch === -1) {\n        if (divideBy === 10 && sign === 0) {\n          return 0;\n        }\n        if (divideBy === 0 && sign === -1) {\n          return 0;\n        }\n      }\n      throw new FormatError(\"Invalid number: \" + String.fromCharCode(ch) + \" (charCode \" + ch + \")\");\n    }\n    sign = sign || 1;\n    var baseValue = ch - 0x30;\n    var powerValue = 0;\n    var powerValueSign = 1;\n    ch = this.nextChar();\n    while (ch >= 0) {\n      if (ch >= 0x30 && ch <= 0x39) {\n        var currentDigit = ch - 0x30;\n        if (eNotation) {\n          powerValue = powerValue * 10 + currentDigit;\n        } else {\n          if (divideBy !== 0) {\n            divideBy *= 10;\n          }\n          baseValue = baseValue * 10 + currentDigit;\n        }\n      } else if (ch === 0x2e) {\n        if (divideBy === 0) {\n          divideBy = 1;\n        } else {\n          break;\n        }\n      } else if (ch === 0x2d) {\n        ch = this.nextChar();\n        continue;\n      } else if (ch === 0x45 || ch === 0x65) {\n        ch = this.peekChar();\n        if (ch === 0x2b || ch === 0x2d) {\n          powerValueSign = ch === 0x2d ? -1 : 1;\n          this.nextChar();\n        } else if (ch < 0x30 || ch > 0x39) {\n          break;\n        }\n        eNotation = true;\n      } else {\n        break;\n      }\n      ch = this.nextChar();\n    }\n    if (divideBy !== 0) {\n      baseValue /= divideBy;\n    }\n    if (eNotation) {\n      baseValue *= Math.pow(10, powerValueSign * powerValue);\n    }\n    return sign * baseValue;\n  };\n  _PdfLexicalOperator.prototype.getString = function () {\n    var numParen = 1;\n    var done = false;\n    var stringBuffer = this.stringBuffer;\n    stringBuffer.length = 0;\n    var ch = this.nextChar();\n    while (true) {\n      // eslint-disable-line\n      var charBuffered = false;\n      switch (ch | 0) {\n        case -1:\n          done = true;\n          break;\n        case 0x28:\n          ++numParen;\n          stringBuffer.push('(');\n          break;\n        case 0x29:\n          if (--numParen === 0) {\n            this.nextChar();\n            done = true;\n          } else {\n            stringBuffer.push(')');\n          }\n          break;\n        case 0x5c:\n          ch = this.nextChar();\n          switch (ch) {\n            case -1:\n              done = true;\n              break;\n            case 0x6e:\n              stringBuffer.push('\\n');\n              break;\n            case 0x72:\n              stringBuffer.push('\\r');\n              break;\n            case 0x74:\n              stringBuffer.push('\\t');\n              break;\n            case 0x62:\n              stringBuffer.push('\\b');\n              break;\n            case 0x66:\n              stringBuffer.push('\\f');\n              break;\n            case 0x5c:\n            case 0x28:\n            case 0x29:\n              stringBuffer.push(String.fromCharCode(ch));\n              break;\n            case 0x30:\n            case 0x31:\n            case 0x32:\n            case 0x33:\n            case 0x34:\n            case 0x35:\n            case 0x36:\n            case 0x37:\n              var x = ch & 0x0f; // eslint-disable-line\n              ch = this.nextChar();\n              charBuffered = true;\n              if (ch >= 0x30 && ch <= 0x37) {\n                x = (x << 3) + (ch & 0x0f);\n                ch = this.nextChar();\n                if (ch >= 0x30 && ch <= 0x37) {\n                  charBuffered = false;\n                  x = (x << 3) + (ch & 0x0f);\n                }\n              }\n              stringBuffer.push(String.fromCharCode(x));\n              break;\n            case 0x0d:\n              if (this.peekChar() === 0x0a) {\n                this.nextChar();\n              }\n              break;\n            case 0x0a:\n              break;\n            default:\n              stringBuffer.push(String.fromCharCode(ch));\n              break;\n          }\n          break;\n        default:\n          stringBuffer.push(String.fromCharCode(ch));\n          break;\n      }\n      if (done) {\n        break;\n      }\n      if (!charBuffered) {\n        ch = this.nextChar();\n      }\n    }\n    return stringBuffer.join('');\n  };\n  _PdfLexicalOperator.prototype.getName = function () {\n    var ch;\n    var previousCh;\n    var stringBuffer = this.stringBuffer;\n    stringBuffer.length = 0;\n    ch = this.nextChar();\n    while (ch >= 0 && !specialChars[ch]) {\n      // eslint-disable-line\n      if (ch === 0x23) {\n        ch = this.nextChar();\n        if (specialChars[ch]) {\n          // eslint-disable-line\n          stringBuffer.push('#');\n          break;\n        }\n        var x = this._toHexDigit(ch);\n        if (x !== -1) {\n          previousCh = ch;\n          ch = this.nextChar();\n          var x2 = this._toHexDigit(ch);\n          if (x2 === -1) {\n            stringBuffer.push('#', String.fromCharCode(previousCh));\n            if (specialChars[ch]) {\n              // eslint-disable-line\n              break;\n            }\n            stringBuffer.push(String.fromCharCode(ch));\n            ch = this.nextChar();\n            continue;\n          }\n          stringBuffer.push(String.fromCharCode(x << 4 | x2));\n        } else {\n          stringBuffer.push('#', String.fromCharCode(ch));\n        }\n      } else {\n        stringBuffer.push(String.fromCharCode(ch));\n      }\n      ch = this.nextChar();\n    }\n    return _PdfName.get(stringBuffer.join(''));\n  };\n  _PdfLexicalOperator.prototype.getHexString = function () {\n    var stringBuffer = this.stringBuffer;\n    stringBuffer.length = 0;\n    var ch = this.currentChar;\n    var isFirstHex = true;\n    var firstDigit;\n    var secondDigit;\n    this._hexStringNumber = 0;\n    while (true) {\n      // eslint-disable-line\n      if (ch < 0) {\n        break;\n      } else if (ch === 0x3e) {\n        this.nextChar();\n        break;\n      } else if (specialChars[ch] === 1) {\n        // eslint-disable-line\n        ch = this.nextChar();\n        continue;\n      } else {\n        if (isFirstHex) {\n          firstDigit = this._toHexDigit(ch);\n          if (firstDigit === -1) {\n            ch = this.nextChar();\n            continue;\n          }\n        } else {\n          secondDigit = this._toHexDigit(ch);\n          if (secondDigit === -1) {\n            ch = this.nextChar();\n            continue;\n          }\n          stringBuffer.push(String.fromCharCode(firstDigit << 4 | secondDigit));\n        }\n        isFirstHex = !isFirstHex;\n        ch = this.nextChar();\n      }\n    }\n    return stringBuffer.join('');\n  };\n  _PdfLexicalOperator.prototype.getObject = function () {\n    var comment = false;\n    var ch = this.currentChar;\n    while (true) {\n      // eslint-disable-line\n      if (ch < 0) {\n        return endOfFile;\n      }\n      if (comment) {\n        if (ch === 0x0a || ch === 0x0d) {\n          comment = false;\n        }\n      } else if (ch === 0x25) {\n        comment = true;\n      } else if (specialChars[ch] !== 1) {\n        // eslint-disable-line\n        break;\n      }\n      ch = this.nextChar();\n    }\n    switch (ch | 0) {\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x2b:\n      case 0x2d:\n      case 0x2e:\n        return this.getNumber();\n      case 0x28:\n        return this.getString();\n      case 0x2f:\n        return this.getName();\n      case 0x5b:\n        this.nextChar();\n        return _PdfCommand.get('[');\n      case 0x5d:\n        this.nextChar();\n        return _PdfCommand.get(']');\n      case 0x3c:\n        ch = this.nextChar();\n        if (ch === 0x3c) {\n          this.nextChar();\n          return _PdfCommand.get('<<');\n        }\n        return this.getHexString();\n      case 0x3e:\n        ch = this.nextChar();\n        if (ch === 0x3e) {\n          this.nextChar();\n          return _PdfCommand.get('>>');\n        }\n        return _PdfCommand.get('>');\n      case 0x7b:\n        this.nextChar();\n        return _PdfCommand.get('{');\n      case 0x7d:\n        this.nextChar();\n        return _PdfCommand.get('}');\n      case 0x29:\n        this.nextChar();\n        throw new FormatError(\"Illegal character: \" + ch);\n    }\n    var str = String.fromCharCode(ch);\n    if (ch < 0x20 || ch > 0x7f) {\n      var nextCh = this.peekChar();\n      if (nextCh >= 0x20 && nextCh <= 0x7f) {\n        this.nextChar();\n        return _PdfCommand.get(str);\n      }\n    }\n    ch = this.nextChar();\n    while (ch >= 0 && !specialChars[ch]) {\n      // eslint-disable-line\n      var possibleCommand = str + String.fromCharCode(ch);\n      if (str.length === 128) {\n        throw new FormatError(\"Command token too long: \" + str.length);\n      }\n      str = possibleCommand;\n      ch = this.nextChar();\n    }\n    if (str === 'true') {\n      return true;\n    }\n    if (str === 'false') {\n      return false;\n    }\n    if (str === 'null') {\n      return null;\n    }\n    if (str === 'BI') {\n      this.beginInlineImagePosition = this.stream.position;\n    }\n    return _PdfCommand.get(str);\n  };\n  _PdfLexicalOperator.prototype.peekObj = function () {\n    var streamPos = this.stream.position;\n    var currentChar = this.currentChar;\n    var beginInlineImagePosition = this.beginInlineImagePosition;\n    var nextObj; // eslint-disable-line\n    try {\n      nextObj = this.getObject();\n    } catch (ex) {} // eslint-disable-line\n    this.stream.position = streamPos;\n    this.currentChar = currentChar;\n    this.beginInlineImagePosition = beginInlineImagePosition;\n    return nextObj;\n  };\n  _PdfLexicalOperator.prototype.skipToNextLine = function () {\n    var ch = this.currentChar;\n    while (ch >= 0) {\n      if (ch === 0x0d) {\n        ch = this.nextChar();\n        if (ch === 0x0a) {\n          this.nextChar();\n        }\n        break;\n      } else if (ch === 0x0a) {\n        this.nextChar();\n        break;\n      }\n      ch = this.nextChar();\n    }\n  };\n  _PdfLexicalOperator.prototype._toHexDigit = function (ch) {\n    if (ch >= 0x30 && ch <= 0x39) {\n      return ch & 0x0f;\n    }\n    if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {\n      return (ch & 0x0f) + 9;\n    }\n    return -1;\n  };\n  return _PdfLexicalOperator;\n}();\nexport { _PdfLexicalOperator };\nvar _PdfParser = /** @class */function () {\n  function _PdfParser(lexicalOperator, xref, allowStreams, recoveryMode) {\n    if (allowStreams === void 0) {\n      allowStreams = false;\n    }\n    if (recoveryMode === void 0) {\n      recoveryMode = false;\n    }\n    this.lexicalOperator = lexicalOperator;\n    this.xref = xref;\n    this.allowStreams = allowStreams;\n    this.recoveryMode = recoveryMode;\n    this.imageCache = new Map();\n    this.refill();\n  }\n  _PdfParser.prototype.refill = function () {\n    this.first = this.lexicalOperator.getObject();\n    this.second = this.lexicalOperator.getObject();\n  };\n  _PdfParser.prototype.shift = function () {\n    if (this.second instanceof _PdfCommand && this.second.command === 'ID') {\n      this.first = this.second;\n      this.second = null;\n    } else {\n      this.first = this.second;\n      this.second = this.lexicalOperator.getObject();\n    }\n  };\n  _PdfParser.prototype.tryShift = function () {\n    try {\n      this.shift();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n  _PdfParser.prototype.getObject = function (cipherTransform) {\n    var first = this.first; // eslint-disable-line\n    this.shift();\n    if (first instanceof _PdfCommand) {\n      switch (first.command) {\n        case 'BI':\n          return this.makeInlineImage(cipherTransform);\n        case '[':\n          var array = []; // eslint-disable-line\n          while (!_isCommand(this.first, ']') && this.first !== endOfFile) {\n            array.push(this.getObject(cipherTransform));\n          }\n          if (this.first === endOfFile) {\n            if (this.recoveryMode) {\n              return array;\n            }\n            throw new ParserEndOfFileException('End of file inside array.');\n          }\n          this.shift();\n          return array;\n        case '<<':\n          var dictionary = new _PdfDictionary(this.xref); // eslint-disable-line\n          while (!_isCommand(this.first, '>>') && this.first !== endOfFile) {\n            if (!(this.first instanceof _PdfName)) {\n              this.shift();\n              continue;\n            }\n            var key = this.first.name;\n            this.shift();\n            var isEnd = this._checkEnd();\n            if (isEnd) {\n              break;\n            }\n            dictionary.set(key, this.getObject(cipherTransform));\n          }\n          if (this.first === endOfFile) {\n            if (this.recoveryMode) {\n              return dictionary;\n            }\n            throw new ParserEndOfFileException('End of file inside dictionary.');\n          }\n          if (_isCommand(this.second, 'stream')) {\n            if (this.allowStreams === true) {\n              return this.makeStream(dictionary, cipherTransform);\n            } else {\n              return dictionary;\n            }\n          }\n          this.shift();\n          return dictionary;\n        default:\n          return first;\n      }\n    }\n    if (Number.isInteger(first)) {\n      if (Number.isInteger(this.first) && _isCommand(this.second, 'R')) {\n        var ref = _PdfReference.get(first, this.first);\n        this.shift();\n        this.shift();\n        return ref;\n      }\n      return first;\n    }\n    if (typeof first === 'string') {\n      if (cipherTransform) {\n        return cipherTransform.decryptString(first);\n      }\n      return first;\n    }\n    return first;\n  };\n  _PdfParser.prototype.findDiscreteDecodeInlineStreamEnd = function (stream) {\n    var startPos = stream.position;\n    var foundEnd = false;\n    var b;\n    var markerLength;\n    b = stream.getByte();\n    while (b !== -1) {\n      if (b !== 0xff) {\n        b = stream.getByte();\n        continue;\n      }\n      switch (stream.getByte()) {\n        case 0x00:\n          break;\n        case 0xff:\n          stream.skip(-1);\n          break;\n        case 0xd9:\n          foundEnd = true;\n          break;\n        case 0xc0:\n        case 0xc1:\n        case 0xc2:\n        case 0xc3:\n        case 0xc5:\n        case 0xc6:\n        case 0xc7:\n        case 0xc9:\n        case 0xca:\n        case 0xcb:\n        case 0xcd:\n        case 0xce:\n        case 0xcf:\n        case 0xc4:\n        case 0xcc:\n        case 0xda:\n        case 0xdb:\n        case 0xdc:\n        case 0xdd:\n        case 0xde:\n        case 0xdf:\n        case 0xe0:\n        case 0xe1:\n        case 0xe2:\n        case 0xe3:\n        case 0xe4:\n        case 0xe5:\n        case 0xe6:\n        case 0xe7:\n        case 0xe8:\n        case 0xe9:\n        case 0xea:\n        case 0xeb:\n        case 0xec:\n        case 0xed:\n        case 0xee:\n        case 0xef:\n        case 0xfe:\n          markerLength = stream.getUnsignedInteger16();\n          if (markerLength > 2) {\n            stream.skip(markerLength - 2);\n          } else {\n            stream.skip(-2);\n          }\n          break;\n      }\n      if (foundEnd) {\n        break;\n      }\n      b = stream.getByte();\n    }\n    var length = stream.position - startPos;\n    if (b === -1) {\n      stream.skip(-length);\n      return this.findDefaultInlineStreamEnd(stream);\n    }\n    this.inlineStreamSkipEI(stream);\n    return length;\n  };\n  _PdfParser.prototype.findDecodeInlineStreamEnd = function (stream) {\n    var startPos = stream.position;\n    var ch;\n    while ((ch = stream.getByte()) !== -1) {\n      // eslint-disable-line\n      if (ch === 0x7e) {\n        var tildePos = stream.position;\n        ch = stream.peekByte();\n        while (_isWhiteSpace(ch)) {\n          stream.skip();\n          ch = stream.peekByte();\n        }\n        if (ch === 0x3e) {\n          stream.skip();\n          break;\n        }\n        if (stream.position > tildePos) {\n          var maybeEI = stream.peekBytes(2);\n          if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {\n            break;\n          }\n        }\n      }\n    }\n    var length = stream.position - startPos;\n    if (ch === -1) {\n      stream.skip(-length);\n      return this.findDefaultInlineStreamEnd(stream);\n    }\n    this.inlineStreamSkipEI(stream);\n    return length;\n  };\n  _PdfParser.prototype.findHexDecodeInlineStreamEnd = function (stream) {\n    var startPos = stream.position;\n    var ch;\n    ch = stream.getByte();\n    while (ch !== -1) {\n      if (ch === 0x3e) {\n        break;\n      }\n      ch = stream.getByte();\n    }\n    var length = stream.position - startPos;\n    if (ch === -1) {\n      stream.skip(-length);\n      return this.findDefaultInlineStreamEnd(stream);\n    }\n    this.inlineStreamSkipEI(stream);\n    return length;\n  };\n  _PdfParser.prototype.inlineStreamSkipEI = function (stream) {\n    var state = 0;\n    var ch;\n    ch = stream.getByte();\n    while (ch !== -1) {\n      if (state === 0) {\n        state = ch === 0x45 ? 1 : 0;\n      } else if (state === 1) {\n        state = ch === 0x49 ? 2 : 0;\n      } else if (state === 2) {\n        break;\n      }\n      ch = stream.getByte();\n    }\n  };\n  _PdfParser.prototype.makeInlineImage = function (cipherTransform) {\n    var lexicalOperator = this.lexicalOperator;\n    var stream = lexicalOperator.stream;\n    var dictionary = new _PdfDictionary(this.xref);\n    var dictLength;\n    while (!_isCommand(this.first, 'ID') && this.first !== endOfFile) {\n      if (!(this.first instanceof _PdfName)) {\n        throw new FormatError('Dictionary key must be a name object');\n      }\n      var key = this.first.name;\n      this.shift();\n      if (this.first.name === endOfFile) {\n        break;\n      }\n      dictionary.set(key, this.getObject(cipherTransform));\n    }\n    if (lexicalOperator.beginInlineImagePosition !== -1) {\n      dictLength = stream.position - lexicalOperator.beginInlineImagePosition;\n    }\n    var filter = dictionary.get('F', 'Filter'); // eslint-disable-line\n    var filterName;\n    if (filter instanceof _PdfName) {\n      filterName = filter.name;\n    } else if (Array.isArray(filter)) {\n      var reference = filter[0]; // eslint-disable-line\n      var filterZero = reference !== null && typeof reference !== 'undefined' && reference instanceof _PdfReference ? this.xref._fetch(reference) : reference;\n      if (filterZero) {\n        filterName = filterZero.name;\n      }\n    }\n    var startPos = stream.position;\n    var length;\n    switch (filterName) {\n      case 'DCT':\n      case 'DCTDecode':\n        length = this.findDiscreteDecodeInlineStreamEnd(stream);\n        break;\n      case 'A85':\n      case 'ASCII85Decode':\n        length = this.findDecodeInlineStreamEnd(stream);\n        break;\n      case 'AHx':\n      case 'ASCIIHexDecode':\n        length = this.findHexDecodeInlineStreamEnd(stream);\n        break;\n      default:\n        length = this.findDefaultInlineStreamEnd(stream);\n    }\n    var imageStream = stream.makeSubStream(startPos, length, dictionary); // eslint-disable-line\n    var cacheKey;\n    if (length < maxCacheLength && dictLength < maxNumberLength) {\n      var imageBytes = imageStream.getBytes();\n      imageStream.reset();\n      var initialStreamPos = stream.position;\n      stream.position = lexicalOperator.beginInlineImagePosition;\n      var dictBytes = stream.getBytes(dictLength);\n      stream.position = initialStreamPos;\n      cacheKey = this._computeMaxNumber(imageBytes) + '_' + this._computeMaxNumber(dictBytes);\n      var cacheEntry = this.imageCache.get(cacheKey);\n      if (cacheEntry !== undefined) {\n        this.second = _PdfCommand.get('EI');\n        this.shift();\n        cacheEntry.reset();\n        return cacheEntry;\n      }\n    }\n    if (cipherTransform) {\n      imageStream = cipherTransform.createStream(imageStream, length);\n    }\n    imageStream = this.filter(imageStream, dictionary, length);\n    imageStream.dictionary = dictionary;\n    if (cacheKey !== undefined) {\n      this.imageCache.set(cacheKey, imageStream);\n    }\n    this.second = _PdfCommand.get('EI');\n    this.shift();\n    return imageStream;\n  };\n  _PdfParser.prototype._computeMaxNumber = function (bytes) {\n    var bytesLength = bytes.length;\n    var a = 1;\n    var b = 0;\n    for (var i = 0; i < bytesLength; ++i) {\n      a += bytes[i] & 0xff; // eslint-disable-line\n      b += a;\n    }\n    return b % 65521 << 16 | a % 65521;\n  };\n  _PdfParser.prototype.makeStream = function (dictionary, cipherTransform) {\n    var lexicalOperator = this.lexicalOperator;\n    var stream = lexicalOperator.stream; // eslint-disable-line\n    lexicalOperator.skipToNextLine();\n    var startPosition = stream.position - 1;\n    var length = dictionary.get('Length');\n    if (!Number.isInteger(length)) {\n      length = 0;\n    }\n    stream.position = startPosition + length;\n    lexicalOperator.nextChar();\n    if (this.tryShift() && _isCommand(this.second, 'endstream')) {\n      this.shift();\n    } else {\n      var endStreamSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);\n      var actualLength = this._findStreamLength(startPosition, endStreamSignature);\n      if (actualLength < 0) {\n        var end = endStreamSignature.length - 1;\n        var truncatedSignature = endStreamSignature.slice(0, end);\n        var maybeLength = this._findStreamLength(startPosition, truncatedSignature);\n        if (maybeLength >= 0) {\n          var lastByte = stream.peekBytes(end + 1)[end]; // eslint-disable-line\n          if (_isWhiteSpace(lastByte)) {\n            actualLength = maybeLength;\n          }\n        }\n        if (actualLength < 0) {\n          throw new FormatError('Missing endstream command.');\n        }\n      }\n      length = actualLength;\n      lexicalOperator.nextChar();\n      this.shift();\n      this.shift();\n    }\n    this.shift();\n    stream = stream.makeSubStream(startPosition, length, dictionary);\n    if (cipherTransform) {\n      stream = cipherTransform.createStream(stream, length);\n    }\n    stream = this.filter(stream, dictionary, length);\n    stream.dictionary = dictionary;\n    return stream;\n  };\n  _PdfParser.prototype.filter = function (stream, dictionary, length) {\n    var filter = dictionary.get('F', 'Filter'); // eslint-disable-line\n    var params = dictionary.get('DP', 'DecodeParms'); // eslint-disable-line\n    if (filter instanceof _PdfName) {\n      return this.makeFilter(stream, filter.name, length, params);\n    }\n    var maybeLength = length;\n    if (Array.isArray(filter)) {\n      var filterArray = filter; // eslint-disable-line\n      var paramsArray = params; // eslint-disable-line\n      for (var i = 0; i < filterArray.length; ++i) {\n        var reference = filterArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n        filter = reference instanceof _PdfReference ? this.xref._fetch(reference) : reference;\n        if (!(filter instanceof _PdfName)) {\n          throw new FormatError(\"Bad filter name '\" + filter + \"'\");\n        }\n        params = null;\n        if (Array.isArray(paramsArray) && i in paramsArray) {\n          var ref = paramsArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n          params = ref instanceof _PdfReference ? this.xref._fetch(ref) : ref;\n        }\n        stream = this.makeFilter(stream, filter.name, maybeLength, params);\n        maybeLength = null;\n      }\n    }\n    return stream;\n  };\n  _PdfParser.prototype.makeFilter = function (stream, name, maybeLength, params) {\n    if (maybeLength === 0) {\n      return new _PdfNullStream();\n    }\n    try {\n      if (name === 'Fl' || name === 'FlateDecode') {\n        if (params) {\n          return new PdfPredictorStream(new _PdfFlateStream(stream, maybeLength), maybeLength, params);\n        }\n        return new _PdfFlateStream(stream, maybeLength);\n      }\n      return stream;\n    } catch (ex) {\n      return new _PdfNullStream();\n    }\n  };\n  _PdfParser.prototype._findStreamLength = function (startPosition, signature) {\n    var stream = this.lexicalOperator.stream;\n    stream.position = startPosition;\n    var length = 2048;\n    var signatureLength = signature.length;\n    while (stream.position < stream.end) {\n      var scanBytes = stream.peekBytes(length);\n      var scanLength = scanBytes.length - signatureLength;\n      if (scanLength <= 0) {\n        break;\n      }\n      var position = 0;\n      while (position < scanLength) {\n        var j = 0;\n        while (j < signatureLength && scanBytes[position + j] === signature[j]) {\n          // eslint-disable-line\n          j++;\n        }\n        if (j >= signatureLength) {\n          stream.position += position;\n          return stream.position - startPosition;\n        }\n        position++;\n      }\n      stream.position += scanLength;\n    }\n    return -1;\n  };\n  _PdfParser.prototype.findDefaultInlineStreamEnd = function (stream) {\n    var startPosition = stream.position;\n    var n = 10;\n    var state = 0;\n    var ch;\n    var endImagePosition;\n    ch = stream.getByte();\n    while (ch !== -1) {\n      if (state === 0) {\n        state = ch === 0x45 ? 1 : 0;\n      } else if (state === 1) {\n        state = ch === 0x49 ? 2 : 0;\n      } else {\n        if (state !== 2) {\n          throw new Error('findDefaultInlineStreamEnd - invalid state.');\n        }\n        if (ch === 0x20 || ch === 0xa || ch === 0xd) {\n          endImagePosition = stream.position;\n          var followingBytes = stream.peekBytes(n);\n          for (var i = 0, ii = followingBytes.length; i < ii; i++) {\n            ch = followingBytes[i]; // eslint-disable-line\n            if (ch === 0x0 && followingBytes[i + 1] !== 0x0) {\n              continue;\n            }\n            if (ch !== 0xa && ch !== 0xd && (ch < 0x20 || ch > 0x7f)) {\n              state = 0;\n              break;\n            }\n          }\n          if (state !== 2) {\n            ch = stream.getByte();\n            continue;\n          }\n          if (state === 2) {\n            break;\n          }\n        } else {\n          state = 0;\n        }\n      }\n      ch = stream.getByte();\n    }\n    if (ch === -1) {\n      if (typeof endImagePosition !== 'undefined') {\n        stream.skip(-(stream.position - endImagePosition));\n      }\n    }\n    var endOffset = 4;\n    stream.skip(-endOffset);\n    ch = stream.peekByte();\n    stream.skip(endOffset);\n    if (!_isWhiteSpace(ch)) {\n      endOffset--;\n    }\n    return stream.position - endOffset - startPosition;\n  };\n  _PdfParser.prototype._checkEnd = function () {\n    if (this.first === endOfFile) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return _PdfParser;\n}();\nexport { _PdfParser };\n/* eslint-disable */\nvar _Linearization = /** @class */function () {\n  function _Linearization(stream) {\n    this.isValid = false;\n    var parser = new _PdfParser(new _PdfLexicalOperator(stream), null);\n    var obj1 = parser.getObject();\n    var obj2 = parser.getObject();\n    var obj3 = parser.getObject();\n    var dictionary = parser.getObject();\n    this.isValid = Number.isInteger(obj1) && Number.isInteger(obj2) && _isCommand(obj3, 'obj') && typeof dictionary !== 'undefined';\n    if (this.isValid) {\n      var obj = dictionary.get('Linearized');\n      this.isValid = typeof obj !== 'undefined' && obj > 0;\n    }\n    if (this.isValid) {\n      var length_1 = this.getInt(dictionary, 'L');\n      if (length_1 !== stream.length) {\n        throw new Error('The L parameter in the linearization dictionary ' + 'does not equal the stream length.');\n      }\n      this.length = length_1;\n      this.hints = this.getHints(dictionary);\n      this.objectNumberFirst = this.getInt(dictionary, 'O');\n      this.endFirst = this.getInt(dictionary, 'E');\n      this.pageCount = this.getInt(dictionary, 'N');\n      this.mainXRefEntriesOffset = this.getInt(dictionary, 'T');\n      this.pageFirst = dictionary.has('P') ? this.getInt(dictionary, 'P', true) : 0;\n    }\n  }\n  _Linearization.prototype.getInt = function (dictionary, name, allowZeroValue) {\n    if (allowZeroValue === void 0) {\n      allowZeroValue = false;\n    }\n    var obj = dictionary.get(name);\n    if (typeof obj !== 'undefined' && Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {\n      return obj;\n    }\n    throw new Error(\"The '\" + name + \"' parameter in the linearization \" + 'dictionary is invalid.');\n  };\n  _Linearization.prototype.getHints = function (dictionary) {\n    var hints = dictionary.getArray('H');\n    var hintsLength = hints.length;\n    if (hints && (hintsLength === 2 || hintsLength === 4)) {\n      for (var index = 0; index < hintsLength; index++) {\n        var hint = hints[index];\n        if (!(Number.isInteger(hint) && hint > 0)) {\n          throw new Error(\"Hint (\" + index + \") in the linearization dictionary is invalid.\");\n        }\n      }\n      return hints;\n    }\n    throw new Error('Hint array in the linearization dictionary is invalid.');\n  };\n  return _Linearization;\n}();\nexport { _Linearization };\n/* eslint-enable */","map":{"version":3,"names":["_PdfCommand","_PdfName","_PdfDictionary","_isCommand","_PdfReference","_isWhiteSpace","FormatError","ParserEndOfFileException","_PdfNullStream","PdfPredictorStream","_PdfFlateStream","maxCacheLength","maxNumberLength","endOfFile","specialChars","_PdfLexicalOperator","stream","nextChar","stringBuffer","_hexStringNumber","beginInlineImagePosition","prototype","currentChar","getByte","peekChar","peekByte","getNumber","ch","eNotation","divideBy","sign","String","fromCharCode","baseValue","powerValue","powerValueSign","currentDigit","Math","pow","getString","numParen","done","length","charBuffered","push","x","join","getName","previousCh","_toHexDigit","x2","get","getHexString","isFirstHex","firstDigit","secondDigit","getObject","comment","str","nextCh","possibleCommand","position","peekObj","streamPos","nextObj","ex","skipToNextLine","_PdfParser","lexicalOperator","xref","allowStreams","recoveryMode","imageCache","Map","refill","first","second","shift","command","tryShift","e","cipherTransform","makeInlineImage","array","dictionary","key","name","isEnd","_checkEnd","set","makeStream","Number","isInteger","ref","decryptString","findDiscreteDecodeInlineStreamEnd","startPos","foundEnd","b","markerLength","skip","getUnsignedInteger16","findDefaultInlineStreamEnd","inlineStreamSkipEI","findDecodeInlineStreamEnd","tildePos","maybeEI","peekBytes","findHexDecodeInlineStreamEnd","state","dictLength","filter","filterName","Array","isArray","reference","filterZero","_fetch","imageStream","makeSubStream","cacheKey","imageBytes","getBytes","reset","initialStreamPos","dictBytes","_computeMaxNumber","cacheEntry","undefined","createStream","bytes","bytesLength","a","i","startPosition","endStreamSignature","Uint8Array","actualLength","_findStreamLength","end","truncatedSignature","slice","maybeLength","lastByte","params","makeFilter","filterArray","paramsArray","parseInt","toString","signature","signatureLength","scanBytes","scanLength","j","n","endImagePosition","Error","followingBytes","ii","endOffset","_Linearization","isValid","parser","obj1","obj2","obj3","obj","length_1","getInt","hints","getHints","objectNumberFirst","endFirst","pageCount","mainXRefEntriesOffset","pageFirst","has","allowZeroValue","getArray","hintsLength","index","hint"],"sources":["/Users/saleem/Desktop/KClient/Web App/Ver_3.6/User Interface/website_Source files/node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-parser.js"],"sourcesContent":["import { _PdfCommand, _PdfName, _PdfDictionary, _isCommand, _PdfReference } from './pdf-primitives';\nimport { _isWhiteSpace, FormatError, ParserEndOfFileException } from './utils';\nimport { _PdfNullStream } from './base-stream';\nimport { PdfPredictorStream } from './predictor-stream';\nimport { _PdfFlateStream } from './flate-stream';\nvar maxCacheLength = 1000;\nvar maxNumberLength = 5552;\nvar endOfFile = 'EOF';\nvar specialChars = [\n    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n];\nvar _PdfLexicalOperator = /** @class */ (function () {\n    function _PdfLexicalOperator(stream) {\n        this.stream = stream;\n        this.nextChar();\n        this.stringBuffer = [];\n        this._hexStringNumber = 0;\n        this.beginInlineImagePosition = -1;\n    }\n    _PdfLexicalOperator.prototype.nextChar = function () {\n        return (this.currentChar = this.stream.getByte());\n    };\n    _PdfLexicalOperator.prototype.peekChar = function () {\n        return this.stream.peekByte();\n    };\n    _PdfLexicalOperator.prototype.getNumber = function () {\n        var ch = this.currentChar;\n        var eNotation = false;\n        var divideBy = 0;\n        var sign = 0;\n        if (ch === 0x2d) {\n            sign = -1;\n            ch = this.nextChar();\n            if (ch === 0x2d) {\n                ch = this.nextChar();\n            }\n        }\n        else if (ch === 0x2b) {\n            sign = 1;\n            ch = this.nextChar();\n        }\n        if (ch === 0x0a || ch === 0x0d) {\n            do {\n                ch = this.nextChar();\n            } while (ch === 0x0a || ch === 0x0d);\n        }\n        if (ch === 0x2e) {\n            divideBy = 10;\n            ch = this.nextChar();\n        }\n        if (ch < 0x30 || ch > 0x39) {\n            if (_isWhiteSpace(ch) || ch === -1) {\n                if (divideBy === 10 && sign === 0) {\n                    return 0;\n                }\n                if (divideBy === 0 && sign === -1) {\n                    return 0;\n                }\n            }\n            throw new FormatError(\"Invalid number: \" + String.fromCharCode(ch) + \" (charCode \" + ch + \")\");\n        }\n        sign = sign || 1;\n        var baseValue = ch - 0x30;\n        var powerValue = 0;\n        var powerValueSign = 1;\n        ch = this.nextChar();\n        while (ch >= 0) {\n            if (ch >= 0x30 && ch <= 0x39) {\n                var currentDigit = ch - 0x30;\n                if (eNotation) {\n                    powerValue = powerValue * 10 + currentDigit;\n                }\n                else {\n                    if (divideBy !== 0) {\n                        divideBy *= 10;\n                    }\n                    baseValue = baseValue * 10 + currentDigit;\n                }\n            }\n            else if (ch === 0x2e) {\n                if (divideBy === 0) {\n                    divideBy = 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (ch === 0x2d) {\n                ch = this.nextChar();\n                continue;\n            }\n            else if (ch === 0x45 || ch === 0x65) {\n                ch = this.peekChar();\n                if (ch === 0x2b || ch === 0x2d) {\n                    powerValueSign = ch === 0x2d ? -1 : 1;\n                    this.nextChar();\n                }\n                else if (ch < 0x30 || ch > 0x39) {\n                    break;\n                }\n                eNotation = true;\n            }\n            else {\n                break;\n            }\n            ch = this.nextChar();\n        }\n        if (divideBy !== 0) {\n            baseValue /= divideBy;\n        }\n        if (eNotation) {\n            baseValue *= Math.pow(10, (powerValueSign * powerValue));\n        }\n        return sign * baseValue;\n    };\n    _PdfLexicalOperator.prototype.getString = function () {\n        var numParen = 1;\n        var done = false;\n        var stringBuffer = this.stringBuffer;\n        stringBuffer.length = 0;\n        var ch = this.nextChar();\n        while (true) { // eslint-disable-line\n            var charBuffered = false;\n            switch (ch | 0) {\n                case -1:\n                    done = true;\n                    break;\n                case 0x28:\n                    ++numParen;\n                    stringBuffer.push('(');\n                    break;\n                case 0x29:\n                    if (--numParen === 0) {\n                        this.nextChar();\n                        done = true;\n                    }\n                    else {\n                        stringBuffer.push(')');\n                    }\n                    break;\n                case 0x5c:\n                    ch = this.nextChar();\n                    switch (ch) {\n                        case -1:\n                            done = true;\n                            break;\n                        case 0x6e:\n                            stringBuffer.push('\\n');\n                            break;\n                        case 0x72:\n                            stringBuffer.push('\\r');\n                            break;\n                        case 0x74:\n                            stringBuffer.push('\\t');\n                            break;\n                        case 0x62:\n                            stringBuffer.push('\\b');\n                            break;\n                        case 0x66:\n                            stringBuffer.push('\\f');\n                            break;\n                        case 0x5c:\n                        case 0x28:\n                        case 0x29:\n                            stringBuffer.push(String.fromCharCode(ch));\n                            break;\n                        case 0x30:\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                        case 0x34:\n                        case 0x35:\n                        case 0x36:\n                        case 0x37:\n                            var x = ch & 0x0f; // eslint-disable-line\n                            ch = this.nextChar();\n                            charBuffered = true;\n                            if (ch >= 0x30 && ch <= 0x37) {\n                                x = (x << 3) + (ch & 0x0f);\n                                ch = this.nextChar();\n                                if (ch >= 0x30 && ch <= 0x37) {\n                                    charBuffered = false;\n                                    x = (x << 3) + (ch & 0x0f);\n                                }\n                            }\n                            stringBuffer.push(String.fromCharCode(x));\n                            break;\n                        case 0x0d:\n                            if (this.peekChar() === 0x0a) {\n                                this.nextChar();\n                            }\n                            break;\n                        case 0x0a:\n                            break;\n                        default:\n                            stringBuffer.push(String.fromCharCode(ch));\n                            break;\n                    }\n                    break;\n                default:\n                    stringBuffer.push(String.fromCharCode(ch));\n                    break;\n            }\n            if (done) {\n                break;\n            }\n            if (!charBuffered) {\n                ch = this.nextChar();\n            }\n        }\n        return stringBuffer.join('');\n    };\n    _PdfLexicalOperator.prototype.getName = function () {\n        var ch;\n        var previousCh;\n        var stringBuffer = this.stringBuffer;\n        stringBuffer.length = 0;\n        ch = this.nextChar();\n        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line\n            if (ch === 0x23) {\n                ch = this.nextChar();\n                if (specialChars[ch]) { // eslint-disable-line\n                    stringBuffer.push('#');\n                    break;\n                }\n                var x = this._toHexDigit(ch);\n                if (x !== -1) {\n                    previousCh = ch;\n                    ch = this.nextChar();\n                    var x2 = this._toHexDigit(ch);\n                    if (x2 === -1) {\n                        stringBuffer.push('#', String.fromCharCode(previousCh));\n                        if (specialChars[ch]) { // eslint-disable-line\n                            break;\n                        }\n                        stringBuffer.push(String.fromCharCode(ch));\n                        ch = this.nextChar();\n                        continue;\n                    }\n                    stringBuffer.push(String.fromCharCode((x << 4) | x2));\n                }\n                else {\n                    stringBuffer.push('#', String.fromCharCode(ch));\n                }\n            }\n            else {\n                stringBuffer.push(String.fromCharCode(ch));\n            }\n            ch = this.nextChar();\n        }\n        return _PdfName.get(stringBuffer.join(''));\n    };\n    _PdfLexicalOperator.prototype.getHexString = function () {\n        var stringBuffer = this.stringBuffer;\n        stringBuffer.length = 0;\n        var ch = this.currentChar;\n        var isFirstHex = true;\n        var firstDigit;\n        var secondDigit;\n        this._hexStringNumber = 0;\n        while (true) { // eslint-disable-line\n            if (ch < 0) {\n                break;\n            }\n            else if (ch === 0x3e) {\n                this.nextChar();\n                break;\n            }\n            else if (specialChars[ch] === 1) { // eslint-disable-line\n                ch = this.nextChar();\n                continue;\n            }\n            else {\n                if (isFirstHex) {\n                    firstDigit = this._toHexDigit(ch);\n                    if (firstDigit === -1) {\n                        ch = this.nextChar();\n                        continue;\n                    }\n                }\n                else {\n                    secondDigit = this._toHexDigit(ch);\n                    if (secondDigit === -1) {\n                        ch = this.nextChar();\n                        continue;\n                    }\n                    stringBuffer.push(String.fromCharCode((firstDigit << 4) | secondDigit));\n                }\n                isFirstHex = !isFirstHex;\n                ch = this.nextChar();\n            }\n        }\n        return stringBuffer.join('');\n    };\n    _PdfLexicalOperator.prototype.getObject = function () {\n        var comment = false;\n        var ch = this.currentChar;\n        while (true) { // eslint-disable-line\n            if (ch < 0) {\n                return endOfFile;\n            }\n            if (comment) {\n                if (ch === 0x0a || ch === 0x0d) {\n                    comment = false;\n                }\n            }\n            else if (ch === 0x25) {\n                comment = true;\n            }\n            else if (specialChars[ch] !== 1) { // eslint-disable-line\n                break;\n            }\n            ch = this.nextChar();\n        }\n        switch (ch | 0) {\n            case 0x30:\n            case 0x31:\n            case 0x32:\n            case 0x33:\n            case 0x34:\n            case 0x35:\n            case 0x36:\n            case 0x37:\n            case 0x38:\n            case 0x39:\n            case 0x2b:\n            case 0x2d:\n            case 0x2e:\n                return this.getNumber();\n            case 0x28:\n                return this.getString();\n            case 0x2f:\n                return this.getName();\n            case 0x5b:\n                this.nextChar();\n                return _PdfCommand.get('[');\n            case 0x5d:\n                this.nextChar();\n                return _PdfCommand.get(']');\n            case 0x3c:\n                ch = this.nextChar();\n                if (ch === 0x3c) {\n                    this.nextChar();\n                    return _PdfCommand.get('<<');\n                }\n                return this.getHexString();\n            case 0x3e:\n                ch = this.nextChar();\n                if (ch === 0x3e) {\n                    this.nextChar();\n                    return _PdfCommand.get('>>');\n                }\n                return _PdfCommand.get('>');\n            case 0x7b:\n                this.nextChar();\n                return _PdfCommand.get('{');\n            case 0x7d:\n                this.nextChar();\n                return _PdfCommand.get('}');\n            case 0x29:\n                this.nextChar();\n                throw new FormatError(\"Illegal character: \" + ch);\n        }\n        var str = String.fromCharCode(ch);\n        if (ch < 0x20 || ch > 0x7f) {\n            var nextCh = this.peekChar();\n            if (nextCh >= 0x20 && nextCh <= 0x7f) {\n                this.nextChar();\n                return _PdfCommand.get(str);\n            }\n        }\n        ch = this.nextChar();\n        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line\n            var possibleCommand = str + String.fromCharCode(ch);\n            if (str.length === 128) {\n                throw new FormatError(\"Command token too long: \" + str.length);\n            }\n            str = possibleCommand;\n            ch = this.nextChar();\n        }\n        if (str === 'true') {\n            return true;\n        }\n        if (str === 'false') {\n            return false;\n        }\n        if (str === 'null') {\n            return null;\n        }\n        if (str === 'BI') {\n            this.beginInlineImagePosition = this.stream.position;\n        }\n        return _PdfCommand.get(str);\n    };\n    _PdfLexicalOperator.prototype.peekObj = function () {\n        var streamPos = this.stream.position;\n        var currentChar = this.currentChar;\n        var beginInlineImagePosition = this.beginInlineImagePosition;\n        var nextObj; // eslint-disable-line\n        try {\n            nextObj = this.getObject();\n        }\n        catch (ex) { } // eslint-disable-line\n        this.stream.position = streamPos;\n        this.currentChar = currentChar;\n        this.beginInlineImagePosition = beginInlineImagePosition;\n        return nextObj;\n    };\n    _PdfLexicalOperator.prototype.skipToNextLine = function () {\n        var ch = this.currentChar;\n        while (ch >= 0) {\n            if (ch === 0x0d) {\n                ch = this.nextChar();\n                if (ch === 0x0a) {\n                    this.nextChar();\n                }\n                break;\n            }\n            else if (ch === 0x0a) {\n                this.nextChar();\n                break;\n            }\n            ch = this.nextChar();\n        }\n    };\n    _PdfLexicalOperator.prototype._toHexDigit = function (ch) {\n        if (ch >= 0x30 && ch <= 0x39) {\n            return ch & 0x0f;\n        }\n        if ((ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66)) {\n            return (ch & 0x0f) + 9;\n        }\n        return -1;\n    };\n    return _PdfLexicalOperator;\n}());\nexport { _PdfLexicalOperator };\nvar _PdfParser = /** @class */ (function () {\n    function _PdfParser(lexicalOperator, xref, allowStreams, recoveryMode) {\n        if (allowStreams === void 0) { allowStreams = false; }\n        if (recoveryMode === void 0) { recoveryMode = false; }\n        this.lexicalOperator = lexicalOperator;\n        this.xref = xref;\n        this.allowStreams = allowStreams;\n        this.recoveryMode = recoveryMode;\n        this.imageCache = new Map();\n        this.refill();\n    }\n    _PdfParser.prototype.refill = function () {\n        this.first = this.lexicalOperator.getObject();\n        this.second = this.lexicalOperator.getObject();\n    };\n    _PdfParser.prototype.shift = function () {\n        if (this.second instanceof _PdfCommand && this.second.command === 'ID') {\n            this.first = this.second;\n            this.second = null;\n        }\n        else {\n            this.first = this.second;\n            this.second = this.lexicalOperator.getObject();\n        }\n    };\n    _PdfParser.prototype.tryShift = function () {\n        try {\n            this.shift();\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    };\n    _PdfParser.prototype.getObject = function (cipherTransform) {\n        var first = this.first; // eslint-disable-line\n        this.shift();\n        if (first instanceof _PdfCommand) {\n            switch (first.command) {\n                case 'BI':\n                    return this.makeInlineImage(cipherTransform);\n                case '[':\n                    var array = []; // eslint-disable-line\n                    while (!_isCommand(this.first, ']') && this.first !== endOfFile) {\n                        array.push(this.getObject(cipherTransform));\n                    }\n                    if (this.first === endOfFile) {\n                        if (this.recoveryMode) {\n                            return array;\n                        }\n                        throw new ParserEndOfFileException('End of file inside array.');\n                    }\n                    this.shift();\n                    return array;\n                case '<<':\n                    var dictionary = new _PdfDictionary(this.xref); // eslint-disable-line\n                    while (!_isCommand(this.first, '>>') && this.first !== endOfFile) {\n                        if (!(this.first instanceof _PdfName)) {\n                            this.shift();\n                            continue;\n                        }\n                        var key = this.first.name;\n                        this.shift();\n                        var isEnd = this._checkEnd();\n                        if (isEnd) {\n                            break;\n                        }\n                        dictionary.set(key, this.getObject(cipherTransform));\n                    }\n                    if (this.first === endOfFile) {\n                        if (this.recoveryMode) {\n                            return dictionary;\n                        }\n                        throw new ParserEndOfFileException('End of file inside dictionary.');\n                    }\n                    if (_isCommand(this.second, 'stream')) {\n                        if (this.allowStreams === true) {\n                            return this.makeStream(dictionary, cipherTransform);\n                        }\n                        else {\n                            return dictionary;\n                        }\n                    }\n                    this.shift();\n                    return dictionary;\n                default:\n                    return first;\n            }\n        }\n        if (Number.isInteger(first)) {\n            if (Number.isInteger(this.first) && _isCommand(this.second, 'R')) {\n                var ref = _PdfReference.get(first, this.first);\n                this.shift();\n                this.shift();\n                return ref;\n            }\n            return first;\n        }\n        if (typeof first === 'string') {\n            if (cipherTransform) {\n                return cipherTransform.decryptString(first);\n            }\n            return first;\n        }\n        return first;\n    };\n    _PdfParser.prototype.findDiscreteDecodeInlineStreamEnd = function (stream) {\n        var startPos = stream.position;\n        var foundEnd = false;\n        var b;\n        var markerLength;\n        b = stream.getByte();\n        while (b !== -1) {\n            if (b !== 0xff) {\n                b = stream.getByte();\n                continue;\n            }\n            switch (stream.getByte()) {\n                case 0x00:\n                    break;\n                case 0xff:\n                    stream.skip(-1);\n                    break;\n                case 0xd9:\n                    foundEnd = true;\n                    break;\n                case 0xc0:\n                case 0xc1:\n                case 0xc2:\n                case 0xc3:\n                case 0xc5:\n                case 0xc6:\n                case 0xc7:\n                case 0xc9:\n                case 0xca:\n                case 0xcb:\n                case 0xcd:\n                case 0xce:\n                case 0xcf:\n                case 0xc4:\n                case 0xcc:\n                case 0xda:\n                case 0xdb:\n                case 0xdc:\n                case 0xdd:\n                case 0xde:\n                case 0xdf:\n                case 0xe0:\n                case 0xe1:\n                case 0xe2:\n                case 0xe3:\n                case 0xe4:\n                case 0xe5:\n                case 0xe6:\n                case 0xe7:\n                case 0xe8:\n                case 0xe9:\n                case 0xea:\n                case 0xeb:\n                case 0xec:\n                case 0xed:\n                case 0xee:\n                case 0xef:\n                case 0xfe:\n                    markerLength = stream.getUnsignedInteger16();\n                    if (markerLength > 2) {\n                        stream.skip(markerLength - 2);\n                    }\n                    else {\n                        stream.skip(-2);\n                    }\n                    break;\n            }\n            if (foundEnd) {\n                break;\n            }\n            b = stream.getByte();\n        }\n        var length = stream.position - startPos;\n        if (b === -1) {\n            stream.skip(-length);\n            return this.findDefaultInlineStreamEnd(stream);\n        }\n        this.inlineStreamSkipEI(stream);\n        return length;\n    };\n    _PdfParser.prototype.findDecodeInlineStreamEnd = function (stream) {\n        var startPos = stream.position;\n        var ch;\n        while ((ch = stream.getByte()) !== -1) { // eslint-disable-line\n            if (ch === 0x7e) {\n                var tildePos = stream.position;\n                ch = stream.peekByte();\n                while (_isWhiteSpace(ch)) {\n                    stream.skip();\n                    ch = stream.peekByte();\n                }\n                if (ch === 0x3e) {\n                    stream.skip();\n                    break;\n                }\n                if (stream.position > tildePos) {\n                    var maybeEI = stream.peekBytes(2);\n                    if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {\n                        break;\n                    }\n                }\n            }\n        }\n        var length = stream.position - startPos;\n        if (ch === -1) {\n            stream.skip(-length);\n            return this.findDefaultInlineStreamEnd(stream);\n        }\n        this.inlineStreamSkipEI(stream);\n        return length;\n    };\n    _PdfParser.prototype.findHexDecodeInlineStreamEnd = function (stream) {\n        var startPos = stream.position;\n        var ch;\n        ch = stream.getByte();\n        while (ch !== -1) {\n            if (ch === 0x3e) {\n                break;\n            }\n            ch = stream.getByte();\n        }\n        var length = stream.position - startPos;\n        if (ch === -1) {\n            stream.skip(-length);\n            return this.findDefaultInlineStreamEnd(stream);\n        }\n        this.inlineStreamSkipEI(stream);\n        return length;\n    };\n    _PdfParser.prototype.inlineStreamSkipEI = function (stream) {\n        var state = 0;\n        var ch;\n        ch = stream.getByte();\n        while (ch !== -1) {\n            if (state === 0) {\n                state = ch === 0x45 ? 1 : 0;\n            }\n            else if (state === 1) {\n                state = ch === 0x49 ? 2 : 0;\n            }\n            else if (state === 2) {\n                break;\n            }\n            ch = stream.getByte();\n        }\n    };\n    _PdfParser.prototype.makeInlineImage = function (cipherTransform) {\n        var lexicalOperator = this.lexicalOperator;\n        var stream = lexicalOperator.stream;\n        var dictionary = new _PdfDictionary(this.xref);\n        var dictLength;\n        while (!_isCommand(this.first, 'ID') && this.first !== endOfFile) {\n            if (!(this.first instanceof _PdfName)) {\n                throw new FormatError('Dictionary key must be a name object');\n            }\n            var key = this.first.name;\n            this.shift();\n            if (this.first.name === endOfFile) {\n                break;\n            }\n            dictionary.set(key, this.getObject(cipherTransform));\n        }\n        if (lexicalOperator.beginInlineImagePosition !== -1) {\n            dictLength = stream.position - lexicalOperator.beginInlineImagePosition;\n        }\n        var filter = dictionary.get('F', 'Filter'); // eslint-disable-line\n        var filterName;\n        if (filter instanceof _PdfName) {\n            filterName = filter.name;\n        }\n        else if (Array.isArray(filter)) {\n            var reference = filter[0]; // eslint-disable-line\n            var filterZero = (reference !== null && typeof reference !== 'undefined' && reference instanceof _PdfReference) ?\n                this.xref._fetch(reference) :\n                reference;\n            if (filterZero) {\n                filterName = filterZero.name;\n            }\n        }\n        var startPos = stream.position;\n        var length;\n        switch (filterName) {\n            case 'DCT':\n            case 'DCTDecode':\n                length = this.findDiscreteDecodeInlineStreamEnd(stream);\n                break;\n            case 'A85':\n            case 'ASCII85Decode':\n                length = this.findDecodeInlineStreamEnd(stream);\n                break;\n            case 'AHx':\n            case 'ASCIIHexDecode':\n                length = this.findHexDecodeInlineStreamEnd(stream);\n                break;\n            default:\n                length = this.findDefaultInlineStreamEnd(stream);\n        }\n        var imageStream = stream.makeSubStream(startPos, length, dictionary); // eslint-disable-line\n        var cacheKey;\n        if (length < maxCacheLength && dictLength < maxNumberLength) {\n            var imageBytes = imageStream.getBytes();\n            imageStream.reset();\n            var initialStreamPos = stream.position;\n            stream.position = lexicalOperator.beginInlineImagePosition;\n            var dictBytes = stream.getBytes(dictLength);\n            stream.position = initialStreamPos;\n            cacheKey = this._computeMaxNumber(imageBytes) + '_' + this._computeMaxNumber(dictBytes);\n            var cacheEntry = this.imageCache.get(cacheKey);\n            if (cacheEntry !== undefined) {\n                this.second = _PdfCommand.get('EI');\n                this.shift();\n                cacheEntry.reset();\n                return cacheEntry;\n            }\n        }\n        if (cipherTransform) {\n            imageStream = cipherTransform.createStream(imageStream, length);\n        }\n        imageStream = this.filter(imageStream, dictionary, length);\n        imageStream.dictionary = dictionary;\n        if (cacheKey !== undefined) {\n            this.imageCache.set(cacheKey, imageStream);\n        }\n        this.second = _PdfCommand.get('EI');\n        this.shift();\n        return imageStream;\n    };\n    _PdfParser.prototype._computeMaxNumber = function (bytes) {\n        var bytesLength = bytes.length;\n        var a = 1;\n        var b = 0;\n        for (var i = 0; i < bytesLength; ++i) {\n            a += bytes[i] & 0xff; // eslint-disable-line\n            b += a;\n        }\n        return (b % 65521 << 16) | a % 65521;\n    };\n    _PdfParser.prototype.makeStream = function (dictionary, cipherTransform) {\n        var lexicalOperator = this.lexicalOperator;\n        var stream = lexicalOperator.stream; // eslint-disable-line\n        lexicalOperator.skipToNextLine();\n        var startPosition = stream.position - 1;\n        var length = dictionary.get('Length');\n        if (!Number.isInteger(length)) {\n            length = 0;\n        }\n        stream.position = startPosition + length;\n        lexicalOperator.nextChar();\n        if (this.tryShift() && _isCommand(this.second, 'endstream')) {\n            this.shift();\n        }\n        else {\n            var endStreamSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);\n            var actualLength = this._findStreamLength(startPosition, endStreamSignature);\n            if (actualLength < 0) {\n                var end = endStreamSignature.length - 1;\n                var truncatedSignature = endStreamSignature.slice(0, end);\n                var maybeLength = this._findStreamLength(startPosition, truncatedSignature);\n                if (maybeLength >= 0) {\n                    var lastByte = stream.peekBytes(end + 1)[end]; // eslint-disable-line\n                    if (_isWhiteSpace(lastByte)) {\n                        actualLength = maybeLength;\n                    }\n                }\n                if (actualLength < 0) {\n                    throw new FormatError('Missing endstream command.');\n                }\n            }\n            length = actualLength;\n            lexicalOperator.nextChar();\n            this.shift();\n            this.shift();\n        }\n        this.shift();\n        stream = stream.makeSubStream(startPosition, length, dictionary);\n        if (cipherTransform) {\n            stream = cipherTransform.createStream(stream, length);\n        }\n        stream = this.filter(stream, dictionary, length);\n        stream.dictionary = dictionary;\n        return stream;\n    };\n    _PdfParser.prototype.filter = function (stream, dictionary, length) {\n        var filter = dictionary.get('F', 'Filter'); // eslint-disable-line\n        var params = dictionary.get('DP', 'DecodeParms'); // eslint-disable-line\n        if (filter instanceof _PdfName) {\n            return this.makeFilter(stream, filter.name, length, params);\n        }\n        var maybeLength = length;\n        if (Array.isArray(filter)) {\n            var filterArray = filter; // eslint-disable-line\n            var paramsArray = params; // eslint-disable-line\n            for (var i = 0; i < filterArray.length; ++i) {\n                var reference = filterArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n                filter = reference instanceof _PdfReference ? this.xref._fetch(reference) : reference;\n                if (!(filter instanceof _PdfName)) {\n                    throw new FormatError(\"Bad filter name '\" + filter + \"'\");\n                }\n                params = null;\n                if (Array.isArray(paramsArray) && i in paramsArray) {\n                    var ref = paramsArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n                    params = ref instanceof _PdfReference ? this.xref._fetch(ref) : ref;\n                }\n                stream = this.makeFilter(stream, filter.name, maybeLength, params);\n                maybeLength = null;\n            }\n        }\n        return stream;\n    };\n    _PdfParser.prototype.makeFilter = function (stream, name, maybeLength, params) {\n        if (maybeLength === 0) {\n            return new _PdfNullStream();\n        }\n        try {\n            if (name === 'Fl' || name === 'FlateDecode') {\n                if (params) {\n                    return new PdfPredictorStream(new _PdfFlateStream(stream, maybeLength), maybeLength, params);\n                }\n                return new _PdfFlateStream(stream, maybeLength);\n            }\n            return stream;\n        }\n        catch (ex) {\n            return new _PdfNullStream();\n        }\n    };\n    _PdfParser.prototype._findStreamLength = function (startPosition, signature) {\n        var stream = this.lexicalOperator.stream;\n        stream.position = startPosition;\n        var length = 2048;\n        var signatureLength = signature.length;\n        while (stream.position < stream.end) {\n            var scanBytes = stream.peekBytes(length);\n            var scanLength = scanBytes.length - signatureLength;\n            if (scanLength <= 0) {\n                break;\n            }\n            var position = 0;\n            while (position < scanLength) {\n                var j = 0;\n                while (j < signatureLength && scanBytes[position + j] === signature[j]) { // eslint-disable-line\n                    j++;\n                }\n                if (j >= signatureLength) {\n                    stream.position += position;\n                    return stream.position - startPosition;\n                }\n                position++;\n            }\n            stream.position += scanLength;\n        }\n        return -1;\n    };\n    _PdfParser.prototype.findDefaultInlineStreamEnd = function (stream) {\n        var startPosition = stream.position;\n        var n = 10;\n        var state = 0;\n        var ch;\n        var endImagePosition;\n        ch = stream.getByte();\n        while (ch !== -1) {\n            if (state === 0) {\n                state = ch === 0x45 ? 1 : 0;\n            }\n            else if (state === 1) {\n                state = ch === 0x49 ? 2 : 0;\n            }\n            else {\n                if (state !== 2) {\n                    throw new Error('findDefaultInlineStreamEnd - invalid state.');\n                }\n                if (ch === 0x20 || ch === 0xa || ch === 0xd) {\n                    endImagePosition = stream.position;\n                    var followingBytes = stream.peekBytes(n);\n                    for (var i = 0, ii = followingBytes.length; i < ii; i++) {\n                        ch = followingBytes[i]; // eslint-disable-line\n                        if (ch === 0x0 && followingBytes[i + 1] !== 0x0) {\n                            continue;\n                        }\n                        if (ch !== 0xa && ch !== 0xd && (ch < 0x20 || ch > 0x7f)) {\n                            state = 0;\n                            break;\n                        }\n                    }\n                    if (state !== 2) {\n                        ch = stream.getByte();\n                        continue;\n                    }\n                    if (state === 2) {\n                        break;\n                    }\n                }\n                else {\n                    state = 0;\n                }\n            }\n            ch = stream.getByte();\n        }\n        if (ch === -1) {\n            if (typeof endImagePosition !== 'undefined') {\n                stream.skip(-(stream.position - endImagePosition));\n            }\n        }\n        var endOffset = 4;\n        stream.skip(-endOffset);\n        ch = stream.peekByte();\n        stream.skip(endOffset);\n        if (!_isWhiteSpace(ch)) {\n            endOffset--;\n        }\n        return stream.position - endOffset - startPosition;\n    };\n    _PdfParser.prototype._checkEnd = function () {\n        if (this.first === endOfFile) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    return _PdfParser;\n}());\nexport { _PdfParser };\n/* eslint-disable */\nvar _Linearization = /** @class */ (function () {\n    function _Linearization(stream) {\n        this.isValid = false;\n        var parser = new _PdfParser(new _PdfLexicalOperator(stream), null);\n        var obj1 = parser.getObject();\n        var obj2 = parser.getObject();\n        var obj3 = parser.getObject();\n        var dictionary = parser.getObject();\n        this.isValid = Number.isInteger(obj1) && Number.isInteger(obj2) && _isCommand(obj3, 'obj') && typeof dictionary !== 'undefined';\n        if (this.isValid) {\n            var obj = dictionary.get('Linearized');\n            this.isValid = typeof obj !== 'undefined' && obj > 0;\n        }\n        if (this.isValid) {\n            var length_1 = this.getInt(dictionary, 'L');\n            if (length_1 !== stream.length) {\n                throw new Error('The L parameter in the linearization dictionary ' + 'does not equal the stream length.');\n            }\n            this.length = length_1;\n            this.hints = this.getHints(dictionary);\n            this.objectNumberFirst = this.getInt(dictionary, 'O');\n            this.endFirst = this.getInt(dictionary, 'E');\n            this.pageCount = this.getInt(dictionary, 'N');\n            this.mainXRefEntriesOffset = this.getInt(dictionary, 'T');\n            this.pageFirst = dictionary.has('P') ? this.getInt(dictionary, 'P', true) : 0;\n        }\n    }\n    _Linearization.prototype.getInt = function (dictionary, name, allowZeroValue) {\n        if (allowZeroValue === void 0) { allowZeroValue = false; }\n        var obj = dictionary.get(name);\n        if (typeof obj !== 'undefined' && Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {\n            return obj;\n        }\n        throw new Error(\"The '\" + name + \"' parameter in the linearization \" + 'dictionary is invalid.');\n    };\n    _Linearization.prototype.getHints = function (dictionary) {\n        var hints = dictionary.getArray('H');\n        var hintsLength = hints.length;\n        if (hints && (hintsLength === 2 || hintsLength === 4)) {\n            for (var index = 0; index < hintsLength; index++) {\n                var hint = hints[index];\n                if (!(Number.isInteger(hint) && hint > 0)) {\n                    throw new Error(\"Hint (\" + index + \") in the linearization dictionary is invalid.\");\n                }\n            }\n            return hints;\n        }\n        throw new Error('Hint array in the linearization dictionary is invalid.');\n    };\n    return _Linearization;\n}());\nexport { _Linearization };\n/* eslint-enable */\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,UAAU,EAAEC,aAAa,QAAQ,kBAAkB;AACnG,SAASC,aAAa,EAAEC,WAAW,EAAEC,wBAAwB,QAAQ,SAAS;AAC9E,SAASC,cAAc,QAAQ,eAAe;AAC9C,SAASC,kBAAkB,QAAQ,oBAAoB;AACvD,SAASC,eAAe,QAAQ,gBAAgB;AAChD,IAAIC,cAAc,GAAG,IAAI;AACzB,IAAIC,eAAe,GAAG,IAAI;AAC1B,IAAIC,SAAS,GAAG,KAAK;AACrB,IAAIC,YAAY,GAAG,CACf,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,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"},"metadata":{},"sourceType":"module","externalDependencies":[]}